import type { ToolSlug } from "./types";

export interface ToolSeoContent {
  whatIs: string;
  howToUse: string;
  features: string[];
  faq: { q: string; a: string }[];
  // Enhanced SEO content for AdSense approval
  whyNeeded?: string; // 왜 이 도구가 필요한가요?
  troubleshooting?: { problem: string; solution: string }[]; // 일반적인 문제 해결
  advantages?: string[]; // DevToolkit만의 차별점
  useCases?: string[]; // 실제 사용 사례
}

export const toolSeoContent = {
  "json-formatter": {
    whatIs:
      "JSON(JavaScript Object Notation)은 데이터를 저장하고 전송하는 가벼운 텍스트 형식입니다. 웹 API, 설정 파일, 데이터베이스 등 현대 소프트웨어 개발의 거의 모든 영역에서 사용됩니다. JSON Formatter는 이러한 JSON 데이터를 자동으로 정리하고 들여쓰기하여 사람이 읽기 쉬운 형태로 변환해주는 온라인 도구입니다. 복잡하게 압축된 JSON도 한 번의 클릭으로 깔끔하게 포맷팅할 수 있습니다.",
    howToUse:
      "사용법은 매우 간단합니다. 왼쪽 입력창에 JSON 데이터를 붙여넣으면 자동으로 오른쪽에 포맷팅된 결과가 표시됩니다. 들여쓰기 크기를 2칸, 4칸, 탭 중에서 선택할 수 있으며, Minify 버튼을 클릭하면 공백 없이 최소화된 JSON을 얻을 수 있습니다. 문법 오류가 있는 경우 정확한 위치와 함께 오류 메시지가 표시되어 빠르게 수정할 수 있습니다.",
    features: [
      "100% 클라이언트 사이드 처리 - 데이터가 서버로 전송되지 않아 민감한 정보도 안전합니다",
      "실시간 문법 검증으로 오류 위치를 즉시 확인하고 수정",
      "다크 모드 지원으로 눈의 피로 감소",
      "복사 버튼으로 결과를 클립보드에 바로 저장",
      "Tree View로 JSON 구조를 시각적으로 탐색",
      "들여쓰기 크기 커스터마이징 (2, 4, Tab)",
    ],
    faq: [
      {
        q: "입력한 JSON이 서버에 저장되나요?",
        a: "아니요. 모든 처리는 100% 브라우저 내에서 이루어지며, 입력 데이터는 어디에도 전송되거나 저장되지 않습니다. 회사의 민감한 API 응답이나 개인 정보가 포함된 데이터도 안심하고 사용할 수 있습니다.",
      },
      {
        q: "대용량 JSON도 처리할 수 있나요?",
        a: "네, 브라우저 메모리가 허용하는 범위 내에서 수 MB 크기까지 문제없이 작동합니다. 10MB 이상의 파일은 처리 시간이 길어질 수 있습니다.",
      },
      {
        q: "JSON 파일을 직접 업로드할 수 있나요?",
        a: "네, 파일을 드래그 앤 드롭하거나 파일 선택 버튼으로 JSON 파일을 직접 업로드할 수 있습니다.",
      },
      {
        q: "포맷팅된 JSON을 파일로 저장할 수 있나요?",
        a: "네, 다운로드 버튼을 클릭하면 .json 파일로 저장됩니다.",
      },
      {
        q: "Minify와 Beautify의 차이점은 무엇인가요?",
        a: "Beautify는 들여쓰기와 줄바꿈을 추가하여 읽기 쉽게 만들고, Minify는 모든 공백을 제거하여 파일 크기를 최소화합니다. API 전송 시에는 Minify, 개발 중에는 Beautify를 사용하세요.",
      },
    ],
    whyNeeded:
      "API 응답을 디버깅할 때, 설정 파일을 수정할 때, 또는 데이터를 분석할 때 압축된 JSON은 읽기가 매우 어렵습니다. 한 줄로 이어진 수천 개의 문자에서 특정 값을 찾는 것은 거의 불가능합니다. JSON Formatter는 이러한 데이터를 계층적으로 정리하여 구조를 한눈에 파악할 수 있게 해줍니다. 또한 문법 오류가 있는 경우 정확한 위치를 알려주어 빠르게 수정할 수 있습니다.",
    troubleshooting: [
      {
        problem: "Unexpected token 에러가 발생합니다",
        solution:
          "JSON 문법 오류입니다. 일반적으로 따옴표 누락, 쉼표 문제, 또는 잘못된 이스케이프 문자가 원인입니다. 오류 위치를 확인하고 해당 부분의 따옴표와 쉼표를 점검하세요.",
      },
      {
        problem: "마지막 항목 뒤에 쉼표가 있습니다 (Trailing comma)",
        solution:
          "JSON 표준에서는 배열이나 객체의 마지막 항목 뒤에 쉼표가 허용되지 않습니다. JavaScript에서는 허용되지만 JSON에서는 오류입니다. 마지막 쉼표를 제거하세요.",
      },
      {
        problem: "키에 따옴표가 없습니다",
        solution:
          'JSON의 모든 키는 큰따옴표(")로 감싸야 합니다. JavaScript 객체와 달리 작은따옴표나 따옴표 없는 키는 허용되지 않습니다.',
      },
      {
        problem: "undefined나 NaN 값이 있습니다",
        solution:
          "JSON은 undefined, NaN, Infinity를 지원하지 않습니다. null, 숫자, 또는 문자열로 대체해야 합니다.",
      },
    ],
    advantages: [
      "회원가입이나 로그인 없이 즉시 사용 가능",
      "100% 무료 - 숨겨진 비용이나 사용 제한 없음",
      "데이터가 서버로 전송되지 않아 기업 환경에서도 안전",
      "PWA 지원으로 오프라인에서도 사용 가능 (앱 설치 후)",
      "Magic Share로 포맷팅된 JSON을 동료와 즉시 공유",
      "다국어 지원 (한국어, 영어, 일본어)",
    ],
    useCases: [
      "REST API 응답 디버깅 및 분석",
      "package.json, tsconfig.json 등 설정 파일 편집",
      "MongoDB, Firebase 등 NoSQL 데이터 검토",
      "웹훅(Webhook) 페이로드 검증",
      "JSON Schema 작성 및 검토",
      "로그 데이터 분석 및 포맷팅",
    ],
  },

  "jwt-decoder": {
    whatIs:
      "JWT(JSON Web Token)는 웹에서 정보를 안전하게 전송하기 위한 표준(RFC 7519)입니다. 주로 인증(Authentication)과 정보 교환에 사용되며, Header, Payload, Signature 세 부분으로 구성됩니다. JWT Decoder는 이러한 JWT 토큰을 디코딩하여 Header, Payload의 내용, 만료 시간, 발급자 정보 등을 사람이 읽을 수 있는 형태로 표시해주는 도구입니다.",
    howToUse:
      "JWT 토큰을 입력창에 붙여넣으면 자동으로 세 부분이 분리되어 디코딩됩니다. Header에서는 알고리즘(HS256, RS256 등)을, Payload에서는 사용자 정보, 권한, 만료 시간 등의 클레임을 확인할 수 있습니다. 토큰이 만료되었는지 여부도 자동으로 표시됩니다.",
    features: [
      "Header, Payload 자동 파싱 및 JSON 포맷팅",
      "만료 시간(exp) 자동 계산 - 만료까지 남은 시간 또는 만료 경과 시간 표시",
      "서버 전송 없이 브라우저에서 100% 안전하게 처리",
      "잘못된 토큰 형식 자동 감지 및 오류 메시지",
      "주요 클레임(iss, sub, aud, exp, iat) 시각적 하이라이트",
      "토큰 구조 시각화 (Header.Payload.Signature)",
    ],
    faq: [
      {
        q: "JWT 서명을 검증할 수 있나요?",
        a: "현재는 디코딩만 지원합니다. 서명 검증을 위해서는 비밀키(HS256) 또는 공개키(RS256)가 필요하며, 보안상의 이유로 클라이언트에서 처리하지 않습니다. 서명 검증은 서버 사이드에서 수행하세요.",
      },
      {
        q: "민감한 토큰을 입력해도 안전한가요?",
        a: "네, 절대적으로 안전합니다. 모든 처리는 100% 브라우저 내에서 이루어지며, 토큰은 서버로 전송되지 않습니다. 네트워크 탭을 확인해 보세요.",
      },
      {
        q: "JWT의 세 부분은 각각 무엇인가요?",
        a: "Header는 토큰 타입과 서명 알고리즘을, Payload는 실제 데이터(클레임)를, Signature는 토큰의 무결성을 검증하는 서명을 담고 있습니다.",
      },
      {
        q: "왜 JWT Payload가 누구나 읽을 수 있나요?",
        a: "JWT의 Payload는 암호화되지 않고 Base64로 인코딩만 됩니다. 따라서 민감한 정보(비밀번호 등)를 Payload에 직접 넣으면 안 됩니다. JWT는 '무결성'을 보장하지, '기밀성'을 보장하지 않습니다.",
      },
      {
        q: "토큰이 만료되었는데 왜 디코딩이 되나요?",
        a: "디코딩과 검증은 별개입니다. 디코딩은 단순히 Base64를 해독하는 것이고, 만료 여부나 서명 검증은 별도의 과정입니다. 서버는 항상 만료 시간과 서명을 검증해야 합니다.",
      },
    ],
    whyNeeded:
      "개발 중 인증 문제를 디버깅할 때 JWT 토큰의 내용을 확인해야 하는 경우가 많습니다. 토큰이 만료되었는지, 올바른 사용자 정보가 포함되어 있는지, 권한(scope/role)이 정확한지 확인해야 합니다. JWT Decoder는 복잡한 Base64 인코딩된 문자열을 즉시 사람이 읽을 수 있는 JSON으로 변환하여 빠른 디버깅을 가능하게 합니다.",
    troubleshooting: [
      {
        problem: "Invalid token format 에러가 발생합니다",
        solution:
          "JWT는 반드시 세 부분(Header.Payload.Signature)으로 구성되어야 합니다. 점(.)이 두 개인지 확인하고, 토큰 앞뒤의 공백이나 줄바꿈을 제거하세요.",
      },
      {
        problem: "토큰이 계속 만료됩니다",
        solution:
          "exp 클레임의 값이 Unix 타임스탬프인지 확인하세요. 밀리초가 아닌 초 단위여야 합니다. 또한 서버와 클라이언트의 시간대가 맞는지 확인하세요.",
      },
      {
        problem: "Payload에 한글이 깨져 보입니다",
        solution:
          "JWT는 UTF-8을 지원하지만, 일부 라이브러리에서 인코딩 문제가 발생할 수 있습니다. 토큰 생성 시 UTF-8 인코딩을 명시적으로 지정하세요.",
      },
      {
        problem: "Bearer 접두사가 포함된 토큰",
        solution:
          "Authorization 헤더에서 복사한 경우 'Bearer ' 접두사가 포함될 수 있습니다. 이 도구는 자동으로 Bearer를 제거하므로 그대로 붙여넣어도 됩니다.",
      },
    ],
    advantages: [
      "Bearer 접두사 자동 제거 - Authorization 헤더에서 바로 복사 가능",
      "만료 시간을 사람이 읽기 쉬운 형식으로 자동 변환",
      "토큰의 각 부분을 색상으로 구분하여 시각화",
      "회원가입 없이 무료로 무제한 사용",
      "100% 클라이언트 사이드 - 민감한 토큰도 안전",
      "Magic Share로 디코딩 결과를 팀원과 공유",
    ],
    useCases: [
      "OAuth 2.0 인증 플로우 디버깅",
      "API 요청 실패 시 토큰 만료 여부 확인",
      "사용자 권한(role/scope) 확인",
      "토큰 클레임 검증 및 테스트",
      "SSO(Single Sign-On) 연동 디버깅",
      "모바일 앱 인증 문제 해결",
    ],
  },

  "image-resizer": {
    whatIs:
      "Image Resizer는 이미지 크기를 조절하고 포맷을 변환하며 품질을 조정할 수 있는 온라인 도구입니다. JPEG, PNG, WebP, GIF 등 다양한 포맷을 지원하며, 모든 처리가 브라우저에서 이루어져 이미지가 외부로 전송되지 않습니다. 웹사이트 최적화, 소셜 미디어 업로드, 이메일 첨부 등 다양한 용도로 활용할 수 있습니다.",
    howToUse:
      "이미지 파일을 드래그 앤 드롭하거나 파일 선택 버튼으로 업로드합니다. 원하는 크기(픽셀 또는 퍼센트)와 출력 포맷을 선택하고, 품질 슬라이더로 압축 수준을 조절합니다. 미리보기에서 결과를 확인하고 다운로드 버튼을 클릭하면 변환된 이미지가 저장됩니다.",
    features: [
      "JPEG, PNG, WebP, GIF 등 다양한 포맷 지원",
      "가로세로 비율 유지/해제 옵션",
      "품질 조절 슬라이더 (1-100%)",
      "100% 브라우저 내 처리로 개인정보 완벽 보호",
      "실시간 미리보기 및 파일 크기 표시",
      "배치 처리로 여러 이미지 동시 변환",
    ],
    faq: [
      {
        q: "최대 처리 가능한 이미지 크기는?",
        a: "브라우저 메모리에 따라 다르지만, 일반적으로 20MB 이하의 이미지를 권장합니다. 매우 큰 이미지는 처리 시간이 길어질 수 있습니다.",
      },
      {
        q: "이미지가 서버에 업로드되나요?",
        a: "아니요. 모든 처리는 100% 브라우저에서 이루어지며 이미지가 외부로 전송되지 않습니다. 네트워크 탭을 확인해 보세요.",
      },
      {
        q: "WebP 포맷은 무엇인가요?",
        a: "Google이 개발한 현대적인 이미지 포맷으로, JPEG보다 25-34% 더 작은 파일 크기를 제공하면서 동일한 품질을 유지합니다.",
      },
      {
        q: "품질을 낮추면 얼마나 작아지나요?",
        a: "이미지에 따라 다르지만, 품질 80%에서도 육안으로 구분하기 어려우며 파일 크기는 50% 이상 줄어들 수 있습니다.",
      },
    ],
    whyNeeded:
      "웹사이트에 최적화되지 않은 이미지를 사용하면 페이지 로딩 속도가 느려지고, 사용자 경험이 저하되며, SEO에도 악영향을 미칩니다. 또한 이메일 첨부나 소셜 미디어에는 파일 크기 제한이 있어 이미지 리사이즈가 필수입니다. Image Resizer는 이러한 작업을 서버 업로드 없이 빠르고 안전하게 처리합니다.",
    troubleshooting: [
      {
        problem: "변환 후 이미지 품질이 떨어집니다",
        solution:
          "품질 슬라이더를 높이세요. JPEG는 85-95%, WebP는 80-90%를 권장합니다. 무손실이 필요하면 PNG를 선택하세요.",
      },
      {
        problem: "투명 배경이 사라졌습니다",
        solution:
          "JPEG는 투명도를 지원하지 않습니다. 투명 배경을 유지하려면 PNG 또는 WebP 포맷을 선택하세요.",
      },
      {
        problem: "이미지가 업로드되지 않습니다",
        solution:
          "지원되는 포맷(JPEG, PNG, WebP, GIF)인지 확인하세요. 파일이 손상되었거나 너무 클 수 있습니다.",
      },
    ],
    advantages: [
      "서버 업로드 없이 100% 브라우저에서 처리 - 개인 사진도 안전",
      "회원가입 없이 무료로 무제한 사용",
      "WebP 등 최신 포맷 지원으로 최적의 압축률",
      "실시간 미리보기로 결과 즉시 확인",
      "배치 처리로 여러 이미지 한 번에 변환",
      "다국어 지원 (한국어, 영어, 일본어)",
    ],
    useCases: [
      "웹사이트 이미지 최적화 및 성능 개선",
      "소셜 미디어용 이미지 크기 조정",
      "이메일 첨부를 위한 파일 크기 축소",
      "블로그 및 쇼핑몰 상품 이미지 편집",
      "프레젠테이션용 이미지 준비",
      "모바일 앱 에셋 생성",
    ],
  },

  "unix-timestamp": {
    whatIs:
      "Unix Timestamp(유닉스 타임스탬프)는 1970년 1월 1일 00:00:00 UTC(Unix Epoch)부터 경과한 초 또는 밀리초를 나타내는 시간 표현 방식입니다. 운영체제, 데이터베이스, API, 로그 시스템 등 거의 모든 컴퓨터 시스템에서 시간을 저장하고 교환하는 표준으로 사용됩니다. Unix Timestamp 변환기는 이러한 숫자 형식의 타임스탬프와 사람이 읽을 수 있는 날짜/시간 형식 간의 양방향 변환을 지원합니다.",
    howToUse:
      "Unix 타임스탬프(예: 1702540800)를 입력하면 해당하는 날짜와 시간으로 변환됩니다. 반대로 날짜와 시간을 선택하면 Unix 타임스탬프가 생성됩니다. 현재 시간의 타임스탬프도 실시간으로 확인할 수 있어 API 테스트나 디버깅에 즉시 활용할 수 있습니다.",
    features: [
      "밀리초(13자리)/초(10자리) 단위 타임스탬프 자동 인식",
      "다양한 날짜 형식 출력 (ISO 8601, RFC 2822 등)",
      "시간대(Timezone) 변환 - UTC, 로컬 및 전 세계 시간대",
      "현재 시간 실시간 타임스탬프 표시",
      "상대 시간 계산 (몇 일 전/후)",
      "100% 클라이언트 사이드 처리",
    ],
    faq: [
      {
        q: "밀리초와 초 단위를 어떻게 구분하나요?",
        a: "13자리 숫자는 밀리초(JavaScript Date 기본값), 10자리 숫자는 초 단위(전통적 Unix 시간)로 자동 인식합니다. 대부분의 프로그래밍 언어와 API 문서에서 어떤 단위를 사용하는지 확인하세요.",
      },
      {
        q: "시간대를 변경할 수 있나요?",
        a: "네, 로컬 시간대와 UTC를 포함한 전 세계 주요 시간대로 변환할 수 있습니다. 서버와 클라이언트 간 시간대 차이로 인한 문제 디버깅에 유용합니다.",
      },
      {
        q: "Unix Epoch란 무엇인가요?",
        a: "1970년 1월 1일 00:00:00 UTC를 기준점(0)으로 하는 시간 체계입니다. 이 날짜 이전은 음수로, 이후는 양수로 표현됩니다.",
      },
      {
        q: "2038년 문제가 무엇인가요?",
        a: "32비트 시스템에서 초 단위 타임스탬프가 2038년 1월 19일에 오버플로우됩니다. 대부분의 현대 시스템은 64비트를 사용하여 이 문제를 해결했습니다.",
      },
    ],
    whyNeeded:
      "API 응답의 타임스탬프를 확인하거나, 로그 파일의 시간을 분석하거나, 데이터베이스 쿼리를 작성할 때 Unix 타임스탬프를 자주 접하게 됩니다. 1702540800이라는 숫자만 보고는 언제인지 알 수 없습니다. 또한 서버와 클라이언트 간 시간대 차이로 인한 버그를 디버깅할 때도 타임스탬프 변환이 필수입니다.",
    troubleshooting: [
      {
        problem: "타임스탬프가 1970년으로 표시됩니다",
        solution:
          "0 또는 매우 작은 숫자가 입력되었을 수 있습니다. 밀리초 단위를 초 단위로 잘못 해석하지 않았는지 확인하세요. JavaScript의 Date.now()는 밀리초를 반환합니다.",
      },
      {
        problem: "시간이 몇 시간 차이가 납니다",
        solution:
          "시간대 문제입니다. 타임스탬프 자체는 UTC 기준이므로, 로컬 시간대로 표시할 때 오프셋이 적용됩니다. UTC와 로컬 시간대를 구분하여 확인하세요.",
      },
      {
        problem: "음수 타임스탬프가 나옵니다",
        solution:
          "1970년 1월 1일 이전의 날짜는 음수로 표현됩니다. 이는 정상적인 동작이며, 대부분의 시스템에서 올바르게 처리됩니다.",
      },
    ],
    advantages: [
      "밀리초/초 단위 자동 감지로 실수 방지",
      "전 세계 시간대 지원으로 국제 프로젝트에 유용",
      "현재 시간 실시간 표시로 즉시 활용 가능",
      "회원가입 없이 무료로 무제한 사용",
      "100% 클라이언트 사이드 - 서버 전송 없음",
      "다양한 출력 형식 지원 (ISO 8601, RFC 2822 등)",
    ],
    useCases: [
      "API 응답의 타임스탬프 확인 및 디버깅",
      "로그 파일 시간 분석",
      "데이터베이스 쿼리 작성 시 날짜 조건 생성",
      "서버-클라이언트 시간대 차이 문제 해결",
      "JWT 토큰의 exp/iat 클레임 확인",
      "Cron 작업 스케줄링 검증",
    ],
  },

  "base64-converter": {
    whatIs:
      "Base64는 바이너리 데이터를 ASCII 문자열로 변환하는 인코딩 방식입니다. 이메일, URL, HTML, CSS 등 텍스트만 허용되는 환경에서 이미지나 파일을 포함시킬 때 사용됩니다. Base64 Converter는 텍스트와 파일을 Base64로 인코딩하거나, Base64 문자열을 원본으로 디코딩하는 양방향 변환 도구입니다.",
    howToUse:
      "인코딩: 텍스트를 입력하거나 파일을 드래그 앤 드롭하면 즉시 Base64 문자열이 생성됩니다. 이미지의 경우 Data URI 형식(data:image/png;base64,...)으로 출력됩니다. 디코딩: Base64 문자열을 입력하면 원본 텍스트가 표시되거나, 파일인 경우 다운로드 버튼이 나타납니다.",
    features: [
      "텍스트 및 모든 종류의 파일 인코딩/디코딩",
      "이미지 Data URI 자동 생성 (HTML/CSS에 바로 사용 가능)",
      "UTF-8 완벽 지원 - 한글, 이모지 등 모든 유니코드 처리",
      "대용량 파일 지원 (브라우저 메모리 한도 내)",
      "원클릭 클립보드 복사",
      "파일 다운로드 기능 (디코딩 시)",
    ],
    faq: [
      {
        q: "이미지를 Base64로 변환할 수 있나요?",
        a: "네, 이미지 파일을 업로드하면 Data URI 형식(data:image/png;base64,...)의 문자열이 생성됩니다. 이를 HTML의 img src나 CSS의 background-image에 직접 사용할 수 있습니다.",
      },
      {
        q: "한글도 인코딩할 수 있나요?",
        a: "네, UTF-8 인코딩을 사용하여 한글, 일본어, 이모지 등 모든 유니코드 문자를 완벽하게 처리합니다.",
      },
      {
        q: "Base64는 암호화인가요?",
        a: "아니요, Base64는 암호화가 아닌 인코딩입니다. 누구나 쉽게 디코딩할 수 있으므로 민감한 정보를 숨기는 용도로 사용하면 안 됩니다.",
      },
      {
        q: "Base64로 인코딩하면 크기가 증가하나요?",
        a: "네, Base64 인코딩은 원본보다 약 33% 크기가 증가합니다. 이는 3바이트의 바이너리를 4개의 ASCII 문자로 표현하기 때문입니다.",
      },
      {
        q: "Data URI와 Base64의 차이점은?",
        a: "Base64는 인코딩 방식이고, Data URI는 Base64로 인코딩된 데이터를 포함하는 URI 스킴입니다. Data URI는 'data:MIME타입;base64,인코딩데이터' 형식입니다.",
      },
    ],
    whyNeeded:
      "이메일로 바이너리 파일을 전송하거나, HTML/CSS에 작은 이미지를 인라인으로 포함시키거나, JSON/XML 등 텍스트 형식으로 바이너리 데이터를 전달해야 할 때 Base64가 필요합니다. 특히 웹 개발에서는 작은 아이콘이나 이미지를 HTTP 요청 없이 CSS에 직접 포함시켜 성능을 개선하는 용도로 자주 사용됩니다.",
    troubleshooting: [
      {
        problem: "디코딩 결과가 깨져 보입니다",
        solution:
          "바이너리 데이터(이미지, PDF 등)를 텍스트로 디코딩하면 깨져 보입니다. 파일 다운로드 기능을 사용하여 원본 파일로 저장하세요.",
      },
      {
        problem: "인코딩 결과가 다른 도구와 다릅니다",
        solution:
          "일부 도구는 URL-safe Base64(+를 -, /를 _로 대체)를 사용합니다. 이 도구는 표준 Base64를 사용합니다.",
      },
      {
        problem: "한글 디코딩이 깨집니다",
        solution:
          "Base64 문자열이 UTF-8이 아닌 다른 인코딩(EUC-KR 등)으로 생성되었을 수 있습니다. 원본 인코딩을 확인하세요.",
      },
      {
        problem: "Data URI가 너무 길어집니다",
        solution:
          "Base64는 크기가 33% 증가합니다. 큰 파일은 별도 URL로 제공하는 것이 좋습니다. Data URI는 수 KB 이하의 작은 파일에 적합합니다.",
      },
    ],
    advantages: [
      "텍스트와 파일 모두 지원하는 올인원 변환기",
      "이미지 Data URI 자동 생성으로 즉시 사용 가능",
      "100% 클라이언트 사이드 - 파일이 서버로 전송되지 않음",
      "UTF-8 완벽 지원으로 다국어 처리",
      "회원가입 없이 무료로 무제한 사용",
      "Magic Share로 인코딩 결과 공유",
    ],
    useCases: [
      "HTML/CSS에 작은 이미지 인라인 삽입",
      "이메일 첨부 파일 인코딩",
      "JSON/XML로 바이너리 데이터 전송",
      "JWT Payload 확인 (내부적으로 Base64URL 사용)",
      "SVG를 CSS background-image로 사용",
      "QR 코드 이미지 인라인 삽입",
    ],
  },

  "app-icon-generator": {
    whatIs:
      "App Icon Generator는 하나의 원본 이미지로 iOS, Android, 웹(Favicon, PWA), macOS, Windows 등 모든 플랫폼에 필요한 앱 아이콘을 일괄 생성하는 도구입니다. 각 플랫폼과 디바이스마다 요구되는 수십 가지 크기와 형식의 아이콘을 자동으로 생성하여 앱 개발 시간을 대폭 절약합니다.",
    howToUse:
      "1024x1024 픽셀 이상의 정사각형 PNG 이미지를 업로드합니다. 필요한 플랫폼(iOS, Android, Web 등)을 선택하면 해당 플랫폼에 맞는 모든 크기의 아이콘이 자동 생성됩니다. 개별 다운로드 또는 ZIP 파일로 일괄 다운로드할 수 있으며, 각 플랫폼별 설정 파일(Contents.json 등)도 함께 생성됩니다.",
    features: [
      "iOS 앱 아이콘 전체 세트 (20x20 ~ 1024x1024, 29종)",
      "Android 앱 아이콘 (mdpi ~ xxxhdpi, mipmap 포함)",
      "Favicon 세트 (ico, 16x16 ~ 512x512 PNG)",
      "PWA 아이콘 (maskable, any purpose)",
      "ZIP 파일 일괄 다운로드 + 설정 파일 포함",
      "100% 브라우저 내 처리 - 이미지가 서버로 전송되지 않음",
    ],
    faq: [
      {
        q: "권장 이미지 크기는?",
        a: "1024x1024 픽셀 이상의 정사각형 PNG 이미지를 권장합니다. 원본 이미지가 클수록 모든 크기에서 선명한 아이콘이 생성됩니다.",
      },
      {
        q: "생성된 아이콘에 워터마크가 추가되나요?",
        a: "아니요, 워터마크 없이 원본 그대로의 깨끗한 아이콘이 생성됩니다. 상업적 앱에도 자유롭게 사용하세요.",
      },
      {
        q: "투명 배경을 사용할 수 있나요?",
        a: "Android와 웹에서는 투명 배경이 지원됩니다. iOS는 투명 배경을 허용하지 않아 자동으로 흰색 배경이 적용됩니다.",
      },
      {
        q: "Android Adaptive Icon이란?",
        a: "Android 8.0 이상에서 지원하는 동적 아이콘 형식으로, 기기 제조사마다 다른 모양(원형, 사각형 등)으로 표시됩니다. 이 도구는 foreground와 background 레이어용 아이콘도 생성합니다.",
      },
    ],
    whyNeeded:
      "앱을 출시하려면 iOS만 해도 29종, Android는 5종 이상의 서로 다른 크기 아이콘이 필요합니다. 웹 Favicon과 PWA까지 포함하면 수십 개의 이미지를 수동으로 만들어야 합니다. 이 과정에서 크기 실수나 형식 오류가 발생하면 앱 심사가 거절될 수 있습니다. App Icon Generator는 이 모든 작업을 자동화하여 시간을 절약하고 오류를 방지합니다.",
    troubleshooting: [
      {
        problem: "생성된 아이콘이 흐릿해 보입니다",
        solution:
          "원본 이미지의 해상도가 낮을 수 있습니다. 1024x1024 픽셀 이상의 선명한 PNG를 사용하세요. JPG 압축 아티팩트도 확대 시 두드러집니다.",
      },
      {
        problem: "iOS 아이콘에 투명 부분이 하얀색으로 변합니다",
        solution:
          "iOS App Store 가이드라인에 따라 앱 아이콘에 투명도가 허용되지 않습니다. 배경색을 명시적으로 지정하거나 흰색 배경을 사용하세요.",
      },
      {
        problem: "ZIP 파일 다운로드가 안 됩니다",
        solution:
          "브라우저의 팝업 차단 기능을 확인하세요. 또는 개별 아이콘 다운로드를 시도해 보세요.",
      },
    ],
    advantages: [
      "모든 플랫폼 아이콘을 한 번에 생성 - 수십 가지 크기 자동 처리",
      "플랫폼별 설정 파일 포함 (Contents.json, AndroidManifest 등)",
      "100% 무료 - 워터마크 없음, 상업용 사용 가능",
      "브라우저 내 처리로 로고/디자인 파일 보안 유지",
      "최신 플랫폼 규격 지원 (iOS 18, Android 14, PWA)",
      "회원가입 없이 즉시 사용",
    ],
    useCases: [
      "모바일 앱 출시 전 아이콘 에셋 생성",
      "PWA(Progressive Web App) 아이콘 준비",
      "웹사이트 Favicon 세트 생성",
      "앱 스토어 스크린샷 및 마케팅 자료 제작",
      "프로토타입 앱 아이콘 빠른 생성",
      "기존 앱 리브랜딩 시 아이콘 일괄 교체",
    ],
  },

  "qr-generator": {
    whatIs:
      "QR(Quick Response) 코드는 스마트폰 카메라로 스캔하여 정보를 빠르게 전달할 수 있는 2차원 바코드입니다. URL, WiFi 접속 정보, 연락처(vCard), 이메일, 전화번호, SMS, 위치 정보 등 다양한 데이터를 담을 수 있습니다. QR Code Generator는 이러한 QR 코드를 쉽게 생성하고, 색상과 크기를 커스터마이징하며, PNG 또는 SVG 형식으로 다운로드할 수 있는 도구입니다.",
    howToUse:
      "QR 코드에 담을 데이터 유형(URL, WiFi, vCard 등)을 선택합니다. 각 유형에 맞는 정보를 입력하면 실시간으로 QR 코드 미리보기가 표시됩니다. 색상, 크기, 오류 정정 레벨 등을 조절한 후 PNG(래스터) 또는 SVG(벡터) 형식으로 다운로드하세요.",
    features: [
      "URL, WiFi, vCard, 이메일, SMS, 전화, 위치 등 다양한 데이터 형식",
      "전경색/배경색 커스터마이징",
      "오류 정정 레벨 설정 (L, M, Q, H)",
      "PNG(래스터)/SVG(벡터) 다운로드",
      "실시간 미리보기",
      "100% 브라우저 내 처리",
    ],
    faq: [
      {
        q: "생성된 QR 코드는 영구적인가요?",
        a: "QR 코드 자체는 영구적이며 만료되지 않습니다. 단, URL을 담은 경우 해당 URL이 유효해야 스캔 시 작동합니다. 정적 QR 코드이므로 내용 변경이 필요하면 새로 생성해야 합니다.",
      },
      {
        q: "로고를 QR 코드 중앙에 넣을 수 있나요?",
        a: "현재 버전에서는 기본 QR 코드 생성을 지원합니다. 로고 삽입 기능은 향후 업데이트에서 추가될 예정입니다.",
      },
      {
        q: "오류 정정 레벨이란 무엇인가요?",
        a: "QR 코드가 일부 손상되어도 읽을 수 있게 하는 복원 능력입니다. L(7%), M(15%), Q(25%), H(30%) 순으로 높아지며, 높을수록 QR 코드가 더 복잡해집니다. 로고를 넣으려면 H 레벨을 권장합니다.",
      },
      {
        q: "WiFi QR 코드는 어떻게 작동하나요?",
        a: "SSID, 비밀번호, 보안 유형을 입력하면 스캔만으로 WiFi에 자동 연결되는 QR 코드가 생성됩니다. 카페, 사무실, 행사장에서 유용합니다.",
      },
    ],
    whyNeeded:
      "QR 코드는 오프라인과 온라인을 연결하는 가장 간편한 방법입니다. 명함에 연락처 QR을 추가하거나, 매장에 WiFi 접속 QR을 배치하거나, 제품 포장에 상세 정보 URL을 담을 수 있습니다. 전문 디자인 도구 없이도 몇 초 만에 깔끔한 QR 코드를 생성할 수 있습니다.",
    troubleshooting: [
      {
        problem: "QR 코드가 스캔되지 않습니다",
        solution:
          "QR 코드 크기가 너무 작거나 대비가 낮을 수 있습니다. 크기를 늘리고, 전경색과 배경색의 대비를 높이세요. 밝은 배경에 어두운 전경색이 가장 잘 인식됩니다.",
      },
      {
        problem: "인쇄 시 QR 코드가 흐릿합니다",
        solution:
          "PNG 대신 SVG 형식으로 다운로드하세요. SVG는 벡터 형식이라 어떤 크기로 인쇄해도 선명합니다.",
      },
      {
        problem: "WiFi QR이 작동하지 않습니다",
        solution:
          "보안 유형(WPA/WPA2/WEP)이 실제 WiFi 설정과 일치하는지 확인하세요. 비밀번호에 특수문자가 있으면 정확히 입력되었는지 확인하세요.",
      },
    ],
    advantages: [
      "다양한 데이터 형식 지원 (URL, WiFi, vCard, 이메일 등)",
      "색상 커스터마이징으로 브랜드에 맞는 QR 생성",
      "SVG 벡터 형식으로 무한 확대 가능",
      "100% 무료 - 생성 횟수 제한 없음",
      "브라우저 내 처리로 민감한 WiFi 비밀번호 보호",
      "회원가입 없이 즉시 사용",
    ],
    useCases: [
      "명함에 연락처(vCard) QR 코드 추가",
      "매장/사무실 WiFi 접속용 QR 코드 제작",
      "제품 포장에 상세 정보 URL 연결",
      "행사 초대장에 위치 정보 QR 삽입",
      "결제 정보 공유 (PayPal, Venmo 등)",
      "앱 다운로드 링크 QR 코드 배포",
    ],
  },

  "color-picker": {
    whatIs:
      "Color Picker는 색상을 선택하고, 이미지에서 색상을 추출하며, HEX, RGB, HSL, CMYK 등 다양한 색상 형식 간 변환을 지원하는 종합 색상 도구입니다. 웹 디자인, UI 개발, 그래픽 작업에서 필요한 정확한 색상 코드를 쉽게 얻을 수 있으며, 조화로운 색상 팔레트를 생성할 수도 있습니다.",
    howToUse:
      "색상 휠이나 슬라이더로 색상을 선택하거나, 이미지를 업로드하여 원하는 위치를 클릭해 색상을 추출합니다. 선택한 색상은 HEX, RGB, HSL 등 다양한 형식으로 즉시 변환되어 표시됩니다. 팔레트에 색상을 저장하고, 클릭 한 번으로 클립보드에 복사할 수 있습니다.",
    features: [
      "직관적인 색상 휠과 슬라이더",
      "이미지에서 스포이드로 색상 추출",
      "HEX, RGB, HSL, CMYK 실시간 변환",
      "색상 팔레트 저장 및 관리",
      "보색, 유사색 등 색상 조화 추천",
      "원클릭 클립보드 복사",
    ],
    faq: [
      {
        q: "어떤 이미지 형식을 지원하나요?",
        a: "JPEG, PNG, GIF, WebP, BMP 등 주요 이미지 형식을 모두 지원합니다. 이미지는 서버로 전송되지 않고 브라우저 내에서 처리됩니다.",
      },
      {
        q: "추출한 색상을 저장할 수 있나요?",
        a: "팔레트에 색상을 추가하면 로컬 스토리지에 저장되어 브라우저를 닫아도 유지됩니다. 팔레트를 내보내거나 가져올 수도 있습니다.",
      },
      {
        q: "HEX와 RGB의 차이는 무엇인가요?",
        a: "HEX는 16진수 표기법(#FF5733), RGB는 빨강/녹색/파랑 값(255, 87, 51)입니다. 웹 CSS에서는 둘 다 사용 가능하며, HEX가 더 간결합니다.",
      },
      {
        q: "인쇄용 색상(CMYK)도 확인할 수 있나요?",
        a: "네, CMYK 값도 함께 표시됩니다. 단, 모니터(RGB)와 인쇄(CMYK)는 색 영역이 달라 약간의 차이가 있을 수 있습니다.",
      },
    ],
    whyNeeded:
      "웹사이트의 특정 색상 코드가 필요하거나, 로고 이미지에서 정확한 브랜드 컬러를 추출하거나, CSS에서 사용할 색상을 변환해야 할 때 Color Picker가 필요합니다. 포토샵 같은 무거운 프로그램 없이도 브라우저에서 바로 전문적인 색상 작업을 할 수 있습니다.",
    troubleshooting: [
      {
        problem: "이미지에서 추출한 색상이 실제와 다릅니다",
        solution:
          "모니터 캘리브레이션이나 이미지 압축으로 인해 색상 차이가 있을 수 있습니다. 원본 이미지나 벡터 파일에서 추출하는 것이 가장 정확합니다.",
      },
      {
        problem: "복사한 HEX 코드가 작동하지 않습니다",
        solution:
          "HEX 코드 앞에 #이 포함되었는지 확인하세요. 일부 프로그램에서는 # 없이 입력해야 합니다.",
      },
      {
        problem: "색상 팔레트가 사라졌습니다",
        solution:
          "브라우저의 로컬 스토리지를 삭제하면 팔레트도 함께 삭제됩니다. 중요한 팔레트는 내보내기 기능으로 백업하세요.",
      },
    ],
    advantages: [
      "이미지 스포이드 기능으로 정확한 색상 추출",
      "실시간 다중 형식 변환 (HEX, RGB, HSL, CMYK)",
      "색상 조화 추천으로 팔레트 디자인 도움",
      "로컬 스토리지로 팔레트 영구 저장",
      "100% 브라우저 내 처리 - 이미지 업로드 불필요",
      "다국어 지원 (한국어, 영어, 일본어)",
    ],
    useCases: [
      "웹사이트/앱 디자인 시 색상 코드 확인",
      "브랜드 가이드라인에서 정확한 색상 추출",
      "CSS/Sass 스타일시트 작성 시 색상 변환",
      "UI 목업에서 색상 일관성 유지",
      "인쇄물과 디지털 간 색상 변환",
      "조화로운 색상 팔레트 생성",
    ],
  },

  "url-parser": {
    whatIs:
      "URL(Uniform Resource Locator)은 웹에서 리소스의 위치를 나타내는 주소입니다. URL Parser는 복잡한 URL을 프로토콜(scheme), 호스트(domain), 포트, 경로(path), 쿼리 파라미터(query string), 해시(fragment) 등 구성 요소로 분해하고 분석하는 도구입니다. 각 부분을 개별적으로 편집하고 새 URL을 생성할 수 있습니다.",
    howToUse:
      "분석할 URL을 입력창에 붙여넣으면 자동으로 각 구성 요소가 표 형태로 분해됩니다. 쿼리 파라미터는 키-값 쌍으로 분리되어 개별 수정이 가능합니다. 파라미터를 추가/수정/삭제한 후 새로운 URL을 생성하고 복사할 수 있습니다.",
    features: [
      "URL 구성 요소 자동 분해 (scheme, host, port, path, query, hash)",
      "쿼리 파라미터 키-값 편집기",
      "URL 인코딩/디코딩 지원",
      "수정된 URL 실시간 재구성",
      "긴 URL 가독성 개선",
      "100% 클라이언트 사이드 처리",
    ],
    faq: [
      {
        q: "인코딩된 URL도 파싱되나요?",
        a: "네, %20이나 %3D 같은 인코딩된 문자도 자동으로 디코딩되어 읽기 쉽게 표시됩니다. 출력 시 다시 인코딩할 수 있습니다.",
      },
      {
        q: "상대 URL도 처리할 수 있나요?",
        a: "상대 URL(/path/to/page)은 호스트 정보가 없어 완전한 파싱이 어렵습니다. 가능하면 전체 URL을 입력하세요.",
      },
      {
        q: "해시(#fragment)와 쿼리 스트링의 차이는?",
        a: "쿼리 스트링(?key=value)은 서버로 전송되지만, 해시(#section)는 브라우저에서만 사용되며 서버로 전송되지 않습니다. 해시는 주로 페이지 내 앵커나 SPA 라우팅에 사용됩니다.",
      },
      {
        q: "URL에서 민감한 정보가 노출되나요?",
        a: "이 도구는 100% 브라우저에서 처리되므로 입력한 URL이 서버로 전송되지 않습니다. 그러나 URL에 포함된 민감한 정보(토큰, 비밀번호)는 조심하세요.",
      },
    ],
    whyNeeded:
      "API 응답에서 받은 긴 URL의 파라미터를 확인하거나, 리다이렉트 URL을 디버깅하거나, 추적 파라미터(UTM)를 분석할 때 URL 파서가 필요합니다. 복잡한 쿼리 스트링을 눈으로 분석하는 것은 실수하기 쉬우며, 특히 인코딩된 URL은 더욱 읽기 어렵습니다.",
    troubleshooting: [
      {
        problem: "URL이 파싱되지 않습니다",
        solution:
          "유효한 URL 형식인지 확인하세요. 최소한 스킴(http:// 또는 https://)과 호스트가 필요합니다. 공백이나 특수문자가 인코딩되지 않았다면 오류가 발생할 수 있습니다.",
      },
      {
        problem: "쿼리 파라미터 값이 깨져 보입니다",
        solution:
          "중첩 인코딩(double encoding)일 수 있습니다. 예: %2520은 %20이 다시 인코딩된 것입니다. 디코딩을 여러 번 시도해 보세요.",
      },
      {
        problem: "포트 번호가 표시되지 않습니다",
        solution:
          "기본 포트(HTTP 80, HTTPS 443)는 URL에 명시되지 않아도 자동으로 적용됩니다. 비표준 포트(예: 8080)만 별도로 표시됩니다.",
      },
    ],
    advantages: [
      "복잡한 URL을 깔끔하게 시각화",
      "쿼리 파라미터 개별 편집 및 재구성",
      "인코딩/디코딩 자동 처리",
      "긴 URL의 가독성 개선",
      "100% 클라이언트 사이드 - URL 정보 보안 유지",
      "회원가입 없이 무료로 무제한 사용",
    ],
    useCases: [
      "API 응답 URL 분석 및 디버깅",
      "UTM 추적 파라미터 확인 및 수정",
      "OAuth 콜백 URL 분석",
      "딥링크 URL 구조 파악",
      "URL shortener 원본 URL 분석",
      "SEO 캐노니컬 URL 검증",
    ],
  },

  "uuid-generator": {
    whatIs:
      "UUID(Universally Unique Identifier)는 전 세계적으로 고유한 128비트 식별자입니다. 데이터베이스 기본키, API 요청 추적, 세션 관리 등 고유한 ID가 필요한 모든 곳에서 사용됩니다. UUID/ULID Generator는 UUID v1(시간 기반), v4(랜덤), v7(시간순 정렬), 그리고 ULID를 생성하는 도구입니다. 한 번에 수천 개의 ID를 생성할 수 있습니다.",
    howToUse:
      "생성할 ID 유형(UUID v1, v4, v7, ULID)을 선택하고 개수를 입력한 후 생성 버튼을 클릭합니다. 생성된 ID는 대문자/소문자, 하이픈 포함/제외 등 형식을 변경할 수 있습니다. 클립보드 복사 또는 텍스트 파일로 다운로드하세요.",
    features: [
      "UUID v1 (시간+MAC 주소 기반)",
      "UUID v4 (완전 랜덤, 가장 일반적)",
      "UUID v7 (시간순 정렬 가능, 최신 표준)",
      "ULID (Crockford Base32, 시간순 정렬)",
      "대량 생성 지원 (최대 10,000개)",
      "다양한 포맷 옵션 (대소문자, 하이픈)",
    ],
    faq: [
      {
        q: "UUID v1과 v4의 차이는?",
        a: "v1은 타임스탬프와 MAC 주소 기반으로 생성 시점을 추적할 수 있지만 개인정보 우려가 있습니다. v4는 완전 랜덤으로 프라이버시가 보장되어 대부분의 경우 권장됩니다.",
      },
      {
        q: "ULID란 무엇인가요?",
        a: "ULID(Universally Unique Lexicographically Sortable Identifier)는 시간순 정렬이 가능하면서도 충돌 확률이 매우 낮은 26자 식별자입니다. 데이터베이스 인덱싱 성능이 좋아 UUID v4의 대안으로 인기가 높아지고 있습니다.",
      },
      {
        q: "UUID 충돌 확률은 얼마나 되나요?",
        a: "UUID v4의 충돌 확률은 천문학적으로 낮습니다. 매초 10억 개씩 100년을 생성해야 50% 충돌 확률에 도달합니다. 실용적으로 충돌을 걱정할 필요가 없습니다.",
      },
      {
        q: "UUID v7은 무엇인가요?",
        a: "2022년에 제안된 최신 UUID 버전으로, 밀리초 정밀도 타임스탬프 + 랜덤 비트로 구성됩니다. 시간순 정렬이 가능하면서도 v1의 프라이버시 문제가 없습니다.",
      },
    ],
    whyNeeded:
      "분산 시스템에서 중앙 서버 없이 고유 ID를 생성해야 할 때 UUID가 필수입니다. 자동 증가 ID는 여러 서버에서 동시에 사용하면 충돌이 발생하지만, UUID는 어디서 생성해도 고유함이 보장됩니다. 데이터베이스 마이그레이션, 마이크로서비스 간 데이터 동기화, API 요청 추적 등에 광범위하게 사용됩니다.",
    troubleshooting: [
      {
        problem: "UUID가 데이터베이스에서 느립니다",
        solution:
          "UUID v4는 랜덤성으로 인해 B-tree 인덱스 성능이 저하될 수 있습니다. 시간순 정렬 가능한 UUID v7이나 ULID를 사용하면 인덱스 성능이 개선됩니다.",
      },
      {
        problem: "UUID 형식이 다른 시스템과 맞지 않습니다",
        solution:
          "하이픈 포함/제외, 대소문자 옵션을 확인하세요. 일부 시스템은 하이픈 없는 32자 형식을 요구합니다.",
      },
      {
        problem: "같은 UUID가 두 번 생성되었습니다",
        solution:
          "UUID v4 충돌은 실질적으로 불가능합니다. 로깅이나 복사 과정에서 중복된 것이 아닌지 확인하세요. 정말 충돌했다면 난수 생성기 문제일 수 있습니다.",
      },
    ],
    advantages: [
      "모든 UUID 버전 (v1, v4, v7) 및 ULID 지원",
      "대량 생성으로 테스트 데이터 빠르게 준비",
      "다양한 포맷 옵션 (대소문자, 하이픈)",
      "100% 클라이언트 사이드 - 보안 랜덤 생성기 사용",
      "회원가입 없이 무료로 무제한 사용",
      "생성 결과 파일 다운로드 지원",
    ],
    useCases: [
      "데이터베이스 기본키(Primary Key) 생성",
      "분산 시스템 간 고유 ID 동기화",
      "API 요청 추적 및 로깅",
      "파일명 고유화 (업로드 파일 등)",
      "테스트 데이터 생성",
      "세션/토큰 식별자 생성",
    ],
  },

  "base-converter": {
    whatIs:
      "컴퓨터는 2진수(Binary)로 작동하고, 사람은 10진수(Decimal)를 사용하며, 프로그래머는 16진수(Hexadecimal)로 메모리와 색상을 표현합니다. Number Base Converter는 2진수, 8진수(Octal), 10진수, 16진수 간의 양방향 변환을 지원하는 도구입니다. 어떤 진법에서 입력해도 나머지 진법으로 동시에 변환됩니다.",
    howToUse:
      "입력할 진법을 선택하고(또는 아무 필드에나) 숫자를 입력하면 다른 모든 진법으로 자동 변환됩니다. 예를 들어 16진수 필드에 'FF'를 입력하면 2진수 '11111111', 10진수 '255', 8진수 '377'이 표시됩니다. 각 결과를 클릭하여 클립보드에 복사할 수 있습니다.",
    features: [
      "2진수(Binary), 8진수(Octal), 10진수(Decimal), 16진수(Hex) 상호 변환",
      "실시간 양방향 변환",
      "BigInt로 큰 숫자 지원",
      "비트 연산 결과 확인",
      "원클릭 클립보드 복사",
      "100% 클라이언트 사이드 처리",
    ],
    faq: [
      {
        q: "음수도 변환할 수 있나요?",
        a: "현재는 양의 정수만 지원합니다. 음수의 2진수 표현(2의 보수)은 비트 수에 따라 달라지므로 별도 처리가 필요합니다.",
      },
      {
        q: "최대 처리 가능한 숫자는?",
        a: "JavaScript BigInt를 사용하여 매우 큰 숫자도 정확하게 처리됩니다. 일반적인 정수 연산에는 제한이 없습니다.",
      },
      {
        q: "16진수에서 대소문자가 중요한가요?",
        a: "숫자 값으로는 같습니다. FF와 ff는 모두 255입니다. 관례적으로 색상 코드는 소문자, 메모리 주소는 대문자를 사용하지만 기술적 차이는 없습니다.",
      },
      {
        q: "0x, 0b 접두사는 무엇인가요?",
        a: "프로그래밍 언어에서 진법을 표시하는 접두사입니다. 0x는 16진수, 0b는 2진수, 0o(또는 0)는 8진수를 나타냅니다. 이 도구에서는 접두사 없이 숫자만 입력하세요.",
      },
    ],
    whyNeeded:
      "CSS 색상 코드(#FF5733), 비트 마스크, 메모리 주소, 파일 권한(chmod 755) 등을 다룰 때 진수 변환이 필요합니다. 디버깅 시 메모리 덤프(16진수)를 분석하거나, 네트워크 패킷을 해석하거나, 비트 연산 결과를 확인할 때도 유용합니다. 계산기로 일일이 변환하는 것보다 훨씬 빠르고 정확합니다.",
    troubleshooting: [
      {
        problem: "입력이 무시됩니다",
        solution:
          "해당 진법에서 유효하지 않은 문자일 수 있습니다. 2진수는 0-1, 8진수는 0-7, 10진수는 0-9, 16진수는 0-9와 A-F만 사용 가능합니다.",
      },
      {
        problem: "예상과 다른 결과가 나옵니다",
        solution:
          "입력 진법이 올바른지 확인하세요. 예를 들어 '10'을 2진수로 입력하면 10진수 2가 되고, 10진수로 입력하면 그대로 10입니다.",
      },
      {
        problem: "소수점이 있는 숫자를 변환할 수 없습니다",
        solution:
          "현재 정수만 지원합니다. 소수점 이하는 별도의 부동소수점 변환기가 필요합니다.",
      },
    ],
    advantages: [
      "모든 주요 진법 동시 변환 (2, 8, 10, 16진수)",
      "BigInt로 큰 숫자도 정확하게 처리",
      "실시간 양방향 변환으로 빠른 확인",
      "프로그래밍 친화적 인터페이스",
      "회원가입 없이 무료로 무제한 사용",
      "100% 클라이언트 사이드 처리",
    ],
    useCases: [
      "CSS 색상 코드 변환 (HEX ↔ RGB)",
      "Unix 파일 권한 분석 (chmod 755 = 111 101 101)",
      "비트 마스크 및 플래그 계산",
      "메모리 주소 및 덤프 분석",
      "네트워크 패킷 데이터 해석",
      "컴퓨터 과학 학습 및 교육",
    ],
  },

  "hash-generator": {
    whatIs:
      "해시(Hash)는 임의 길이의 데이터를 고정 길이의 고유한 문자열로 변환하는 단방향 함수입니다. 동일한 입력은 항상 동일한 해시값을 생성하지만, 해시값에서 원본 데이터를 복원하는 것은 불가능합니다. Hash Generator는 MD5, SHA-1, SHA-256, SHA-512 등 다양한 해시 알고리즘을 지원하며, WebAssembly 기반 hash-wasm 라이브러리로 네이티브에 가까운 성능을 제공합니다.",
    howToUse:
      "텍스트를 직접 입력하거나 파일을 드래그 앤 드롭하세요. 사용할 해시 알고리즘을 선택하면 즉시 해시값이 생성됩니다. 여러 알고리즘의 결과를 동시에 확인하거나, 두 해시값을 비교하여 파일 무결성을 검증할 수 있습니다.",
    features: [
      "MD5, SHA-1, SHA-256, SHA-512 등 7가지 알고리즘 지원",
      "WebAssembly(Wasm) 기반 고성능 처리",
      "대용량 파일 스트리밍 해싱 지원",
      "해시값 비교 기능으로 무결성 검증",
      "100% 클라이언트 사이드 - 파일이 서버로 전송되지 않음",
      "실시간 진행률 표시 (대용량 파일)",
    ],
    faq: [
      {
        q: "어떤 해시 알고리즘을 사용해야 하나요?",
        a: "보안이 중요한 경우 SHA-256 이상을 권장합니다. MD5와 SHA-1은 충돌 공격에 취약점이 알려져 있어 비밀번호 저장이나 보안 목적으로는 사용하지 마세요. 단순 파일 무결성 검사에는 MD5도 충분합니다.",
      },
      {
        q: "대용량 파일도 해싱할 수 있나요?",
        a: "네, 스트리밍 방식으로 처리하여 수 GB 크기의 파일도 메모리 부족 없이 해싱할 수 있습니다. 진행률이 표시되어 처리 상태를 확인할 수 있습니다.",
      },
      {
        q: "해시와 암호화의 차이점은 무엇인가요?",
        a: "해시는 단방향 함수로 원본을 복원할 수 없지만, 암호화는 복호화가 가능합니다. 비밀번호는 해시로 저장하고, 메시지는 암호화합니다.",
      },
      {
        q: "같은 해시값을 가진 다른 데이터가 있을 수 있나요?",
        a: "이론적으로 '충돌'이 가능하지만, SHA-256 같은 강력한 알고리즘에서는 실질적으로 불가능합니다. MD5는 의도적인 충돌 생성이 가능해 보안 목적으로는 권장하지 않습니다.",
      },
      {
        q: "파일 해시는 어떤 용도로 사용되나요?",
        a: "소프트웨어 다운로드 검증, 파일 변조 감지, 중복 파일 탐지, 디지털 서명, 블록체인 등 다양한 분야에서 사용됩니다.",
      },
    ],
    whyNeeded:
      "파일을 다운로드한 후 원본과 동일한지 확인하거나, 두 파일이 완전히 같은 내용인지 비교할 때 해시가 필요합니다. 수 GB 크기의 파일을 일일이 비교하는 것은 불가능하지만, 해시값은 항상 고정 길이(SHA-256의 경우 64자)이므로 빠르게 비교할 수 있습니다. 또한 비밀번호를 안전하게 저장하거나 데이터 무결성을 검증하는 데에도 해시가 필수적입니다.",
    troubleshooting: [
      {
        problem: "해시값이 예상과 다릅니다",
        solution:
          "입력 끝에 줄바꿈이나 공백이 포함되지 않았는지 확인하세요. 또한 텍스트 인코딩(UTF-8 vs ASCII)에 따라 결과가 달라질 수 있습니다.",
      },
      {
        problem: "파일 해시가 공식 사이트와 다릅니다",
        solution:
          "파일이 완전히 다운로드되었는지 확인하세요. 일부만 다운로드된 파일은 다른 해시값을 생성합니다. 또한 알고리즘이 동일한지 확인하세요.",
      },
      {
        problem: "대용량 파일 해싱이 느립니다",
        solution:
          "WebAssembly 기반으로 처리하여 JavaScript보다 훨씬 빠르지만, 파일 크기에 따라 시간이 걸릴 수 있습니다. 브라우저 탭을 닫지 마세요.",
      },
    ],
    advantages: [
      "WebAssembly 기반으로 네이티브에 가까운 성능",
      "대용량 파일도 메모리 부족 없이 스트리밍 처리",
      "파일이 서버로 전송되지 않아 100% 안전",
      "7가지 해시 알고리즘 동시 지원",
      "해시 비교 기능으로 빠른 무결성 검증",
      "PWA로 오프라인에서도 사용 가능",
    ],
    useCases: [
      "소프트웨어 다운로드 무결성 검증",
      "파일 변조 감지 및 보안 감사",
      "중복 파일 탐지 및 정리",
      "비밀번호 해시 테스트 (개발 목적)",
      "ISO 이미지 검증",
      "데이터 백업 무결성 확인",
    ],
  },

  "sql-formatter": {
    whatIs:
      "SQL(Structured Query Language)은 데이터베이스를 조작하는 표준 언어입니다. SQL Formatter는 복잡한 SQL 쿼리를 읽기 쉽게 정리하고, 들여쓰기와 키워드 대소문자를 일관되게 포맷팅하는 도구입니다. MySQL, PostgreSQL, Oracle, SQL Server, SQLite, BigQuery 등 다양한 SQL 방언(dialect)을 지원합니다.",
    howToUse:
      "SQL 쿼리를 입력창에 붙여넣고, 사용 중인 데이터베이스에 맞는 SQL 방언을 선택합니다. Format 버튼을 클릭하면 들여쓰기, 키워드 대소문자, 줄바꿈이 정리된 쿼리가 출력됩니다. 탭/공백 크기, 키워드 대소문자 스타일 등을 커스터마이징할 수 있습니다.",
    features: [
      "MySQL, PostgreSQL, Oracle, SQL Server, SQLite, BigQuery 등 지원",
      "키워드 대문자/소문자 자동 변환",
      "들여쓰기 및 줄바꿈 자동 정리",
      "서브쿼리 및 CTE 계층적 포맷팅",
      "구문 강조(Syntax Highlighting) 표시",
      "100% 클라이언트 사이드 처리",
    ],
    faq: [
      {
        q: "지원하는 SQL 방언은?",
        a: "MySQL, MariaDB, PostgreSQL, Oracle PL/SQL, SQL Server T-SQL, SQLite, Amazon Redshift, Google BigQuery, Snowflake 등 주요 데이터베이스를 모두 지원합니다.",
      },
      {
        q: "복잡한 서브쿼리도 포맷팅되나요?",
        a: "네, 중첩된 서브쿼리, CTE(Common Table Expression), 윈도우 함수, CASE WHEN 등 복잡한 구문도 계층적으로 깔끔하게 포맷팅됩니다.",
      },
      {
        q: "포맷팅이 쿼리 실행에 영향을 주나요?",
        a: "아니요, 포맷팅은 가독성을 위한 것이며 쿼리의 실행 결과나 성능에는 영향을 주지 않습니다. 데이터베이스는 공백과 줄바꿈을 무시합니다.",
      },
      {
        q: "주석도 보존되나요?",
        a: "네, 한 줄 주석(--)과 블록 주석(/* */) 모두 보존됩니다.",
      },
    ],
    whyNeeded:
      "한 줄로 압축된 SQL 쿼리는 디버깅이 어렵고, 코드 리뷰 시 변경 사항을 파악하기 힘듭니다. 특히 여러 JOIN, 서브쿼리, 조건절이 포함된 복잡한 쿼리는 포맷팅 없이는 이해하기 거의 불가능합니다. 팀원 간 일관된 SQL 스타일을 유지하고, 쿼리 오류를 빠르게 발견하기 위해 SQL Formatter가 필수입니다.",
    troubleshooting: [
      {
        problem: "포맷팅 후 쿼리가 작동하지 않습니다",
        solution:
          "올바른 SQL 방언을 선택했는지 확인하세요. MySQL과 PostgreSQL은 문법이 다릅니다. 또한 원본 쿼리에 문법 오류가 있었을 수 있습니다.",
      },
      {
        problem: "특정 키워드가 인식되지 않습니다",
        solution:
          "데이터베이스별 고유 함수나 최신 문법은 인식되지 않을 수 있습니다. 일반 SQL 문법은 대부분 지원됩니다.",
      },
      {
        problem: "들여쓰기가 예상과 다릅니다",
        solution:
          "탭/공백 크기 설정을 확인하세요. 팀 컨벤션에 맞게 2칸, 4칸, 탭을 선택할 수 있습니다.",
      },
    ],
    advantages: [
      "10개 이상의 SQL 방언 지원",
      "서브쿼리, CTE 등 복잡한 구문 처리",
      "팀 코딩 스타일에 맞는 커스터마이징",
      "주석 보존 및 구문 강조",
      "100% 브라우저 내 처리 - 쿼리 내용 보안",
      "회원가입 없이 무료로 무제한 사용",
    ],
    useCases: [
      "코드 리뷰 전 SQL 쿼리 정리",
      "레거시 쿼리 가독성 개선",
      "SQL 학습 및 교육 자료 작성",
      "데이터 분석 쿼리 문서화",
      "저장 프로시저 및 함수 정리",
      "마이그레이션 스크립트 검토",
    ],
  },

  "cron-parser": {
    whatIs:
      "Cron은 Unix/Linux 시스템에서 작업을 자동 스케줄링하는 표준 도구입니다. Cron 표현식(예: '0 9 * * 1-5')은 작업 실행 시간을 정의하지만, 직관적으로 이해하기 어렵습니다. Cron Parser는 이러한 Cron 표현식을 사람이 읽을 수 있는 설명('평일 오전 9시')으로 변환하고, 다음 실행 시간을 예측하는 도구입니다.",
    howToUse:
      "Cron 표현식(5개 또는 6개 필드)을 입력하면 즉시 해당 스케줄의 설명이 표시됩니다. 다음 10회 또는 사용자가 지정한 횟수의 실행 시간이 예측되어 표시됩니다. 역으로, 원하는 스케줄을 선택하면 해당하는 Cron 표현식을 생성할 수도 있습니다.",
    features: [
      "5필드(분 시 일 월 요일) 및 6필드(초 포함) Cron 지원",
      "사람이 읽을 수 있는 설명 생성 (한국어/영어)",
      "다음 N회 실행 시간 예측",
      "시간대(Timezone) 설정 가능",
      "자주 사용되는 Cron 표현식 예제",
      "역방향 생성 - 스케줄 → Cron 표현식",
    ],
    faq: [
      {
        q: "6개 필드 Cron은 무엇인가요?",
        a: "표준 Cron은 5필드(분 시 일 월 요일)이지만, 일부 스케줄러(Spring, Quartz 등)는 초를 포함한 6필드를 사용합니다. 첫 번째 필드가 초입니다.",
      },
      {
        q: "비표준 Cron 문법도 지원하나요?",
        a: "@yearly, @monthly, @weekly, @daily, @hourly 같은 별칭과 L(마지막), W(평일), #(N번째 요일) 같은 확장 문법을 지원합니다.",
      },
      {
        q: "* 와 ?의 차이는 무엇인가요?",
        a: "대부분의 시스템에서 *는 '모든 값', ?는 '특정 값 없음'을 의미합니다. 일과 요일 필드에서 둘 중 하나는 ?를 사용해야 하는 시스템도 있습니다.",
      },
      {
        q: "0 0 * * SUN과 0 0 * * 0의 차이는?",
        a: "같습니다. 요일은 0-6(일-토) 또는 SUN-SAT으로 표현할 수 있습니다. 일부 시스템은 7도 일요일로 해석합니다.",
      },
    ],
    whyNeeded:
      "'30 4 1,15 * *'가 언제 실행되는지 머릿속으로 계산하기는 어렵습니다. Cron 표현식 오류는 예약 작업 실패, 백업 누락, 리포트 지연 등 심각한 문제를 일으킬 수 있습니다. 프로덕션에 배포하기 전에 Cron Parser로 의도한 스케줄과 일치하는지 반드시 확인하세요.",
    troubleshooting: [
      {
        problem: "표현식이 예상과 다르게 해석됩니다",
        solution:
          "요일 필드가 0-6(일-토)인지 1-7(월-일)인지 확인하세요. 시스템마다 다를 수 있습니다. 또한 시간대 설정을 확인하세요.",
      },
      {
        problem: "6필드 표현식이 작동하지 않습니다",
        solution:
          "6필드(초 포함)는 표준 Cron이 아닌 확장 형식입니다. crontab에서는 5필드만 사용하고, Spring/Quartz에서는 6필드를 사용합니다.",
      },
      {
        problem: "L, W, # 같은 문자가 인식되지 않습니다",
        solution:
          "이러한 확장 문법은 Quartz 등 일부 스케줄러에서만 지원됩니다. 표준 crontab에서는 사용할 수 없습니다.",
      },
    ],
    advantages: [
      "복잡한 Cron 표현식을 즉시 이해 가능한 설명으로 변환",
      "다음 실행 시간 미리 확인으로 오류 방지",
      "5필드/6필드, 다양한 확장 문법 지원",
      "시간대 설정으로 글로벌 팀 협업 지원",
      "자주 사용되는 표현식 예제 제공",
      "역방향 생성으로 쉽게 표현식 작성",
    ],
    useCases: [
      "배치 작업 스케줄 설정 및 검증",
      "백업 자동화 시간 확인",
      "CI/CD 파이프라인 스케줄 테스트",
      "데이터 동기화 작업 계획",
      "알림/리포트 발송 시간 설정",
      "AWS CloudWatch, Azure, GCP 스케줄러 설정",
    ],
  },

  "markdown-preview": {
    whatIs:
      "Markdown Preview는 Markdown 문서를 실시간으로 렌더링하여 미리볼 수 있는 도구입니다. 코드 하이라이팅과 GFM(GitHub Flavored Markdown)을 지원합니다.",
    howToUse:
      "왼쪽에 Markdown을 작성하면 오른쪽에 실시간으로 렌더링된 결과가 표시됩니다. 스크롤이 동기화되어 편집 위치를 쉽게 확인할 수 있습니다.",
    features: [
      "실시간 렌더링",
      "GFM(테이블, 체크리스트 등) 지원",
      "코드 구문 강조",
      "다크 모드 지원",
    ],
    faq: [
      {
        q: "이미지를 미리볼 수 있나요?",
        a: "외부 URL 이미지는 미리보기가 가능합니다. 로컬 이미지는 Data URI로 변환해야 합니다.",
      },
      {
        q: "HTML을 직접 사용할 수 있나요?",
        a: "네, Markdown 내에서 HTML 태그를 사용할 수 있습니다.",
      },
    ],
    whyNeeded:
      "README, 기술 문서, 블로그 포스트를 작성할 때 최종 결과물이 어떻게 보일지 즉시 확인해야 합니다. 로컬 에디터에서 작성 후 GitHub에 푸시했더니 테이블이 깨지거나 코드 블록이 제대로 렌더링되지 않는 경험이 있으신가요? 실시간 미리보기로 이런 문제를 사전에 방지할 수 있습니다.",
    troubleshooting: [
      {
        problem: "테이블이 제대로 표시되지 않습니다",
        solution:
          "GFM 테이블 문법을 확인하세요. 헤더 행과 구분선(---|---|---)이 필요하며, 각 셀은 파이프(|)로 구분합니다.",
      },
      {
        problem: "코드 하이라이팅이 적용되지 않습니다",
        solution:
          "코드 블록 시작 부분에 언어를 명시하세요. 예: ```javascript 또는 ```python",
      },
      {
        problem: "이미지가 표시되지 않습니다",
        solution:
          "외부 URL 이미지는 HTTPS로 시작해야 합니다. 로컬 이미지는 Base64 Data URI로 변환하거나 이미지 호스팅 서비스를 이용하세요.",
      },
    ],
    advantages: [
      "GFM(GitHub Flavored Markdown) 완벽 지원으로 GitHub README와 동일한 렌더링",
      "실시간 동기화 스크롤로 긴 문서도 편하게 편집",
      "100개 이상 언어의 코드 구문 강조(Syntax Highlighting)",
      "다크/라이트 모드 지원으로 눈의 피로 감소",
      "로컬 처리로 민감한 문서 내용 보호",
    ],
    useCases: [
      "GitHub README.md 파일 작성 및 검토",
      "기술 블로그 포스트 초안 작성",
      "API 문서 및 개발자 가이드 작성",
      "위키 페이지 및 프로젝트 문서화",
      "마크다운 문법 학습 및 실습",
      "이메일용 마크다운 템플릿 미리보기",
    ],
  },

  "diff-checker": {
    whatIs:
      "Diff Checker는 두 텍스트의 차이점을 비교하고 변경 사항을 시각적으로 표시하는 도구입니다. 코드 리뷰나 문서 비교에 유용합니다.",
    howToUse:
      "왼쪽과 오른쪽에 비교할 텍스트를 각각 입력합니다. 자동으로 차이점이 강조되어 표시되며, 추가/삭제/수정된 부분을 색상으로 구분합니다.",
    features: [
      "라인 단위/문자 단위 비교",
      "추가/삭제/수정 색상 구분",
      "Side by Side 보기",
      "변경점 네비게이션",
    ],
    faq: [
      {
        q: "대소문자를 무시하고 비교할 수 있나요?",
        a: "현재는 대소문자를 구분하여 비교합니다.",
      },
      {
        q: "파일을 직접 비교할 수 있나요?",
        a: "텍스트를 복사하여 붙여넣거나, 파일을 드래그 앤 드롭할 수 있습니다.",
      },
    ],
    whyNeeded:
      "코드 리뷰, 설정 파일 변경 확인, 문서 버전 비교 등 '무엇이 바뀌었는지'를 정확히 파악해야 할 때가 많습니다. 눈으로 두 텍스트를 비교하는 것은 실수하기 쉽고 시간이 오래 걸립니다. Diff 도구는 변경 사항을 즉시 시각화하여 누락된 변경이나 의도치 않은 수정을 빠르게 발견할 수 있게 합니다.",
    troubleshooting: [
      {
        problem: "공백이나 줄바꿈 차이가 너무 많이 표시됩니다",
        solution:
          "Trim Whitespace 옵션을 활성화하거나, 비교 전 양쪽 텍스트의 줄바꿈 형식(CRLF/LF)을 통일하세요.",
      },
      {
        problem: "변경된 부분이 한 덩어리로 표시됩니다",
        solution:
          "문자 단위 비교 모드로 전환하면 더 세밀한 차이를 확인할 수 있습니다. 라인 단위는 전체 라인을, 문자 단위는 개별 문자 차이를 보여줍니다.",
      },
      {
        problem: "대용량 텍스트 비교가 느립니다",
        solution:
          "브라우저에서 처리하므로 매우 큰 파일(수 MB 이상)은 분할하여 비교하거나, 관심 있는 섹션만 추출하여 비교하세요.",
      },
    ],
    advantages: [
      "라인 단위와 문자 단위 비교 모드 선택으로 필요에 맞는 상세도 조절",
      "추가(초록), 삭제(빨강), 수정(노랑) 색상 코딩으로 직관적인 이해",
      "Side-by-side 뷰로 양쪽 텍스트를 동시에 확인",
      "변경점 간 이동 네비게이션으로 빠른 검토",
      "로컬 처리로 민감한 코드나 문서 보안 유지",
    ],
    useCases: [
      "Pull Request 전 로컬 코드 변경 사항 최종 확인",
      "설정 파일(config, yaml, json) 버전 간 차이 비교",
      "데이터베이스 스키마 변경 검토",
      "계약서나 문서의 수정 이력 추적",
      "빌드 결과물이나 로그 파일 비교",
      "병합 충돌 해결을 위한 버전 비교",
    ],
  },

  "lorem-generator": {
    whatIs:
      "Lorem Ipsum Generator는 디자인이나 레이아웃 테스트용 더미 텍스트를 생성하는 도구입니다. 단어, 문장, 문단 단위로 원하는 만큼 생성할 수 있습니다.",
    howToUse:
      "생성할 단위(단어/문장/문단)와 개수를 선택하고 생성 버튼을 클릭합니다. 생성된 텍스트는 클립보드에 복사할 수 있습니다.",
    features: [
      "단어/문장/문단 단위 생성",
      "수량 조절 가능",
      "클래식 Lorem Ipsum 텍스트",
      "클립보드 복사",
    ],
    faq: [
      {
        q: "Lorem Ipsum이란?",
        a: "출판 및 디자인 업계에서 레이아웃 테스트용으로 사용되는 표준 더미 텍스트입니다.",
      },
      {
        q: "한글 더미 텍스트도 생성되나요?",
        a: "현재는 라틴어 기반의 Lorem Ipsum만 지원합니다.",
      },
    ],
    whyNeeded:
      "웹사이트나 앱 디자인 중 '여기에 텍스트가 들어갑니다'라는 문구를 반복해서 쓰는 것은 비전문적이고, 실제 콘텐츠가 어떻게 보일지 파악하기 어렵습니다. Lorem Ipsum은 실제 텍스트와 유사한 글자 분포와 길이를 가지고 있어 레이아웃 테스트에 이상적입니다.",
    troubleshooting: [
      {
        problem: "생성된 텍스트가 너무 짧습니다",
        solution:
          "단위를 '문단'으로 변경하거나 개수를 늘려보세요. 문단 단위는 4-6개 문장을 포함합니다.",
      },
      {
        problem: "항상 같은 텍스트가 생성됩니다",
        solution:
          "Lorem Ipsum은 표준 텍스트 풀에서 추출됩니다. 랜덤 모드를 활성화하면 순서가 섞인 텍스트를 생성할 수 있습니다.",
      },
    ],
    advantages: [
      "단어/문장/문단 단위로 정밀하게 텍스트 양 조절",
      "표준 Lorem Ipsum으로 전문적인 디자인 목업 제작",
      "클릭 한 번으로 클립보드에 복사",
      "디자인 도구나 에디터에 바로 붙여넣기 가능",
      "어떤 분량이든 즉시 생성",
    ],
    useCases: [
      "웹/앱 UI 목업 및 와이어프레임 텍스트 채우기",
      "블로그 레이아웃 테스트 시 게시글 미리보기",
      "타이포그래피 및 폰트 테스트",
      "반응형 디자인에서 텍스트 영역 테스트",
      "프레젠테이션 슬라이드 레이아웃 확인",
      "인쇄물 디자인 프루프 제작",
    ],
  },

  "url-encoder": {
    whatIs:
      "URL Encoder/Decoder는 URL에서 사용할 수 없는 특수 문자를 인코딩하거나, 인코딩된 URL을 원본으로 디코딩하는 도구입니다.",
    howToUse:
      "인코딩할 문자열을 입력하고 Encode 버튼을 클릭하거나, 인코딩된 문자열을 입력하고 Decode 버튼을 클릭합니다.",
    features: [
      "URL 인코딩/디코딩",
      "UTF-8 완벽 지원",
      "실시간 변환",
      "특수문자 처리",
    ],
    faq: [
      {
        q: "어떤 문자가 인코딩되나요?",
        a: "공백, 한글, 특수문자 등 URL에서 직접 사용할 수 없는 문자가 %XX 형식으로 인코딩됩니다.",
      },
      {
        q: "전체 URL을 인코딩해야 하나요?",
        a: "일반적으로 쿼리 파라미터 값만 인코딩합니다. 전체 URL을 인코딩하면 작동하지 않을 수 있습니다.",
      },
    ],
    whyNeeded:
      "URL에서 공백, 한글, 특수문자 등은 그대로 사용할 수 없습니다. 브라우저는 이런 문자를 자동으로 인코딩하지만, API 호출이나 수동 URL 구성 시에는 직접 인코딩해야 합니다. 인코딩을 하지 않으면 서버가 파라미터를 잘못 해석하거나 URL이 깨지는 문제가 발생합니다.",
    troubleshooting: [
      {
        problem: "인코딩 후 URL이 작동하지 않습니다",
        solution:
          "전체 URL이 아닌 파라미터 값만 인코딩하세요. '?', '&', '=' 같은 URL 구조 문자까지 인코딩하면 URL이 깨집니다.",
      },
      {
        problem: "이중 인코딩이 발생했습니다",
        solution:
          "이미 인코딩된 문자열(예: %20)을 다시 인코딩하면 %2520이 됩니다. 입력 문자열이 이미 인코딩되어 있는지 확인하세요.",
      },
      {
        problem: "한글이 깨져서 나옵니다",
        solution:
          "UTF-8 인코딩을 사용하세요. 서버와 클라이언트의 인코딩 방식이 일치해야 합니다. 본 도구는 UTF-8을 기본으로 사용합니다.",
      },
    ],
    advantages: [
      "encodeURIComponent와 encodeURI 차이를 이해할 필요 없이 즉시 변환",
      "UTF-8 완벽 지원으로 한글, 일본어, 이모지 등 모든 문자 처리",
      "인코딩/디코딩 양방향 변환 즉시 가능",
      "실시간 결과 확인으로 빠른 작업",
      "브라우저 전송 없이 로컬에서 처리하여 보안 유지",
    ],
    useCases: [
      "API 쿼리 파라미터에 특수문자 포함 시 인코딩",
      "OAuth 콜백 URL의 redirect_uri 인코딩",
      "검색 쿼리 문자열 URL 안전하게 구성",
      "이메일 링크의 한글 파라미터 처리",
      "인코딩된 URL 파라미터 원본 확인",
      "디버깅 시 URL 디코딩하여 가독성 확보",
    ],
  },

  "html-entity": {
    whatIs:
      "HTML Entity Encoder는 HTML 특수 문자(<, >, &, 따옴표 등)를 HTML 엔티티로 변환하거나 역변환하는 도구입니다. XSS 방지 및 HTML 작성에 유용합니다.",
    howToUse:
      "텍스트를 입력하고 Encode 버튼을 클릭하면 HTML 엔티티로 변환됩니다. 반대로 엔티티가 포함된 텍스트를 Decode할 수도 있습니다.",
    features: [
      "HTML 특수문자 인코딩/디코딩",
      "숫자형/이름형 엔티티 지원",
      "XSS 방지용 이스케이프",
      "실시간 변환",
    ],
    faq: [
      {
        q: "XSS 방지에 어떻게 사용하나요?",
        a: "사용자 입력을 HTML에 표시하기 전에 인코딩하면 스크립트 실행을 방지할 수 있습니다.",
      },
      {
        q: "모든 HTML 엔티티를 지원하나요?",
        a: "표준 HTML 엔티티를 모두 지원합니다.",
      },
    ],
    whyNeeded:
      "HTML에서 '<'나 '>'를 그대로 작성하면 태그로 인식되어 페이지가 깨지거나 보안 취약점(XSS)이 발생합니다. 사용자 입력을 웹 페이지에 표시하기 전에 HTML 엔티티로 인코딩하면 악성 스크립트 실행을 방지하고 텍스트를 안전하게 표시할 수 있습니다.",
    troubleshooting: [
      {
        problem: "&amp;amp; 처럼 이중 인코딩이 됩니다",
        solution:
          "이미 인코딩된 텍스트를 다시 인코딩하면 &가 &amp;로 변환됩니다. 입력이 이미 인코딩되어 있는지 먼저 확인하세요.",
      },
      {
        problem: "특정 문자가 인코딩되지 않습니다",
        solution:
          "기본적으로 <, >, &, \", ' 등 HTML에서 특별한 의미를 갖는 문자만 인코딩됩니다. 모든 비ASCII 문자 인코딩이 필요하면 전체 인코딩 옵션을 사용하세요.",
      },
      {
        problem: "디코딩 결과가 이상합니다",
        solution:
          "숫자형 엔티티(&#60;)와 이름형 엔티티(&lt;)가 혼합되어 있을 수 있습니다. 본 도구는 양쪽 모두 지원합니다.",
      },
    ],
    advantages: [
      "XSS(Cross-Site Scripting) 공격 방지를 위한 필수 이스케이프 처리",
      "숫자형 엔티티(&#60;)와 이름형 엔티티(&lt;) 모두 지원",
      "HTML 소스 코드 내에서 특수문자 표시 가능",
      "인코딩/디코딩 양방향 변환 즉시 가능",
      "로컬 처리로 보안 데이터도 안전하게 변환",
    ],
    useCases: [
      "사용자 입력(댓글, 게시글)을 웹 페이지에 안전하게 표시",
      "코드 예제에서 HTML 태그를 텍스트로 표시",
      "이메일 템플릿에서 특수문자 인코딩",
      "XML 데이터 내 특수문자 처리",
      "CMS나 WYSIWYG 에디터 콘텐츠 처리",
      "보안 감사 시 XSS 취약점 테스트",
    ],
  },

  "box-shadow": {
    whatIs:
      "Box Shadow Generator는 CSS box-shadow 속성을 시각적으로 편집하고 코드를 생성하는 도구입니다. 다양한 파라미터를 조절하며 실시간으로 결과를 확인할 수 있습니다.",
    howToUse:
      "슬라이더로 그림자의 위치, 크기, 흐림, 색상 등을 조절합니다. 미리보기에서 결과를 확인하고 생성된 CSS 코드를 복사하여 사용하세요.",
    features: [
      "실시간 미리보기",
      "다중 그림자 지원",
      "내부 그림자(inset) 지원",
      "CSS 코드 자동 생성",
    ],
    faq: [
      {
        q: "여러 개의 그림자를 추가할 수 있나요?",
        a: "네, 여러 레이어의 그림자를 추가하여 복합적인 효과를 만들 수 있습니다.",
      },
      {
        q: "생성된 코드는 모든 브라우저에서 작동하나요?",
        a: "box-shadow는 모든 최신 브라우저에서 지원됩니다.",
      },
    ],
    whyNeeded:
      "box-shadow 속성은 수치와 색상 조합이 복잡하여 코드만으로는 결과를 예측하기 어렵습니다. 'box-shadow: 5px 5px 10px rgba(0,0,0,0.3)'라고 써도 실제로 어떻게 보일지 렌더링 전까지 알 수 없습니다. 시각적 편집기로 실시간 미리보기를 보며 조절하면 원하는 디자인을 빠르게 구현할 수 있습니다.",
    troubleshooting: [
      {
        problem: "그림자가 잘려서 보입니다",
        solution:
          "부모 요소에 overflow: hidden이 적용되어 있을 수 있습니다. 그림자가 요소 바깥으로 확장되므로 충분한 여백이 필요합니다.",
      },
      {
        problem: "여러 그림자가 겹쳐서 진하게 보입니다",
        solution:
          "다중 그림자 사용 시 각 레이어의 투명도를 조절하세요. RGBA 색상에서 알파 값(투명도)을 낮추면 부드러운 효과를 얻을 수 있습니다.",
      },
      {
        problem: "inset 그림자가 보이지 않습니다",
        solution:
          "inset 그림자는 요소 내부에 렌더링됩니다. 요소의 배경색과 그림자 색상이 비슷하면 구분이 안 될 수 있습니다.",
      },
    ],
    advantages: [
      "실시간 미리보기로 코드 작성 없이 디자인 조절",
      "다중 그림자 레이어로 복합적인 효과 구현",
      "내부 그림자(inset) 지원으로 입체감 표현",
      "RGBA 색상으로 정밀한 투명도 조절",
      "생성된 CSS 코드 클릭 한 번으로 복사",
      "모든 최신 브라우저 호환",
    ],
    useCases: [
      "카드 UI 컴포넌트의 입체감 있는 그림자 디자인",
      "버튼 호버/클릭 상태의 눌림 효과 구현",
      "모달이나 드롭다운의 부유 효과 적용",
      "네오모피즘(Neumorphism) 디자인 구현",
      "Material Design 스타일의 elevation 표현",
      "포커스 상태 하이라이트 효과",
    ],
  },

  "gradient-generator": {
    whatIs:
      "Gradient Generator는 CSS 그라디언트를 시각적으로 편집하고 코드를 생성하는 도구입니다. Linear, Radial 그라디언트를 지원합니다.",
    howToUse:
      "그라디언트 유형을 선택하고 색상 정지점을 추가/수정합니다. 각도나 위치를 조절하고 생성된 CSS 코드를 복사하여 사용하세요.",
    features: [
      "Linear/Radial 그라디언트",
      "다중 색상 정지점",
      "각도/방향 조절",
      "CSS 코드 자동 생성",
    ],
    faq: [
      {
        q: "Conic 그라디언트도 지원하나요?",
        a: "현재는 Linear와 Radial 그라디언트를 지원합니다.",
      },
      {
        q: "프리셋 그라디언트가 있나요?",
        a: "인기 있는 그라디언트 프리셋을 제공합니다.",
      },
    ],
    whyNeeded:
      "CSS 그라디언트 문법은 직관적이지 않습니다. 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'처럼 각도, 색상 정지점, 위치를 모두 지정해야 하며, 코드만으로는 결과를 예측하기 어렵습니다. 시각적 편집기로 색상과 방향을 조절하며 실시간으로 결과를 확인하면 원하는 그라디언트를 빠르게 만들 수 있습니다.",
    troubleshooting: [
      {
        problem: "그라디언트가 예상과 다른 방향으로 나타납니다",
        solution:
          "Linear 그라디언트의 각도는 0deg가 아래에서 위, 90deg가 왼쪽에서 오른쪽입니다. 방향 키워드(to right, to bottom)가 더 직관적입니다.",
      },
      {
        problem: "색상 전환이 부자연스럽습니다",
        solution:
          "색상 정지점 사이에 중간 색상을 추가하거나, 정지점 위치를 조절하세요. 비슷한 색상 계열끼리 전환하면 더 부드럽습니다.",
      },
      {
        problem: "IE에서 그라디언트가 표시되지 않습니다",
        solution:
          "IE는 CSS 그라디언트 지원이 제한적입니다. filter 속성이나 이미지 대체를 고려하세요. 모던 브라우저에서는 문제없이 작동합니다.",
      },
    ],
    advantages: [
      "Linear와 Radial 그라디언트를 시각적으로 편집",
      "다중 색상 정지점으로 복잡한 그라디언트 생성",
      "각도와 방향을 직접 드래그하여 조절",
      "인기 있는 그라디언트 프리셋으로 빠른 시작",
      "생성된 CSS 코드 즉시 복사",
      "실시간 미리보기로 결과 확인",
    ],
    useCases: [
      "웹사이트 배경 그라디언트 디자인",
      "버튼이나 카드의 화려한 배경 효과",
      "히어로 섹션의 오버레이 그라디언트",
      "텍스트 그라디언트 효과(background-clip)",
      "로딩 애니메이션 배경",
      "브랜드 컬러 기반 그라디언트 팔레트 생성",
    ],
  },

  "ua-parser": {
    whatIs:
      "User Agent Parser는 브라우저 User Agent 문자열을 분석하여 브라우저, 운영체제, 디바이스 정보를 추출하는 도구입니다.",
    howToUse:
      "User Agent 문자열을 입력하면 자동으로 파싱되어 브라우저 이름/버전, OS, 디바이스 유형 등이 표시됩니다. 현재 브라우저의 UA도 확인할 수 있습니다.",
    features: [
      "브라우저/버전 감지",
      "OS 및 버전 감지",
      "디바이스 유형 감지",
      "현재 UA 자동 표시",
    ],
    faq: [
      {
        q: "모든 브라우저를 인식하나요?",
        a: "주요 브라우저와 일반적인 봇을 인식합니다. 매우 오래되거나 희귀한 UA는 정확도가 낮을 수 있습니다.",
      },
      {
        q: "모바일과 데스크톱을 구분할 수 있나요?",
        a: "네, 디바이스 유형(모바일/태블릿/데스크톱)을 구분합니다.",
      },
    ],
    whyNeeded:
      "User Agent 문자열은 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36...'처럼 복잡하고 읽기 어렵습니다. 사용자가 어떤 브라우저, OS, 디바이스를 사용하는지 빠르게 파악해야 할 때 UA Parser가 필요합니다. 특히 버그 리포트 분석이나 사용자 환경 디버깅에 필수적입니다.",
    troubleshooting: [
      {
        problem: "브라우저가 잘못 인식됩니다",
        solution:
          "일부 브라우저는 다른 브라우저의 UA를 포함합니다(호환성 목적). Chrome UA에 Safari가 포함된 것은 정상입니다. 가장 구체적인 브라우저 이름이 실제 브라우저입니다.",
      },
      {
        problem: "봇인지 확인하고 싶습니다",
        solution:
          "Googlebot, Bingbot 등 주요 검색 엔진 봇은 UA에 명시됩니다. 'bot', 'crawler', 'spider' 키워드를 확인하세요.",
      },
      {
        problem: "UA가 비정상적으로 짧습니다",
        solution:
          "일부 앱이나 봇은 간략한 UA를 사용합니다. 또는 User Agent Spoofing이 적용되었을 수 있습니다.",
      },
    ],
    advantages: [
      "복잡한 UA 문자열을 구조화된 정보로 즉시 분석",
      "브라우저 이름, 버전, 엔진 정보 추출",
      "OS 종류와 버전 식별",
      "디바이스 유형(모바일/태블릿/데스크톱) 구분",
      "현재 브라우저의 UA 자동 표시",
      "주요 봇 및 크롤러 인식",
    ],
    useCases: [
      "버그 리포트에서 사용자 환경 분석",
      "Analytics 데이터의 UA 해석",
      "특정 브라우저/OS 대상 기능 개발",
      "웹 서버 로그 분석",
      "크로스 브라우저 테스트 환경 확인",
      "봇 트래픽 식별 및 분석",
    ],
  },

  "regex-tester": {
    whatIs:
      "정규 표현식(Regular Expression, Regex)은 문자열에서 특정 패턴을 찾거나 치환하기 위한 강력한 도구입니다. 이메일 유효성 검사, 전화번호 추출, 로그 분석 등 텍스트 처리의 거의 모든 영역에서 사용됩니다. Regex Tester는 정규 표현식을 실시간으로 테스트하고, 매칭 결과를 시각적으로 확인하며, 캡처 그룹을 분석할 수 있는 도구입니다.",
    howToUse:
      "상단에 정규식 패턴을 입력하고, 아래에 테스트할 문자열을 입력하세요. 매칭되는 부분이 즉시 하이라이트됩니다. 플래그(g, i, m, s)를 선택하여 전역 검색, 대소문자 무시, 다중 라인 모드 등을 설정할 수 있습니다. 캡처 그룹이 있다면 각 그룹의 매칭 결과도 표시됩니다.",
    features: [
      "실시간 매칭 하이라이트 - 입력과 동시에 결과 확인",
      "캡처 그룹 및 명명된 그룹 표시",
      "모든 플래그 지원 (g, i, m, s, u, y)",
      "매치 인덱스, 길이, 값 상세 정보",
      "일반적인 정규식 패턴 예제 제공",
      "JavaScript RegExp 엔진 사용",
    ],
    faq: [
      {
        q: "JavaScript 정규식 문법을 사용하나요?",
        a: "네, JavaScript의 RegExp 엔진을 사용합니다. PCRE(Perl)나 다른 언어와 미세한 차이가 있을 수 있으니 실제 환경에서 재검증하세요.",
      },
      {
        q: "치환(replace) 테스트도 가능한가요?",
        a: "현재는 매칭 테스트에 집중하고 있습니다. 치환 기능은 향후 업데이트에서 추가될 예정입니다.",
      },
      {
        q: "정규식이 느리거나 멈추는 이유는?",
        a: "복잡한 패턴(특히 중첩된 반복자)은 'ReDoS'라고 불리는 성능 문제를 일으킬 수 있습니다. 패턴을 단순화하거나 구체적으로 만들어보세요.",
      },
      {
        q: "g 플래그는 무엇인가요?",
        a: "Global 플래그로, 첫 번째 매치만이 아닌 모든 매치를 찾습니다. 없으면 첫 번째 매치에서 중단됩니다.",
      },
      {
        q: "이메일 검증 정규식을 추천해 주세요",
        a: "완벽한 이메일 정규식은 매우 복잡합니다. 간단한 검증에는 /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/를 사용하고, 실제 검증은 확인 이메일 발송으로 하세요.",
      },
    ],
    whyNeeded:
      "정규 표현식은 강력하지만 복잡합니다. 작은 실수로 의도하지 않은 결과가 나올 수 있고, 디버깅이 어렵습니다. Regex Tester는 패턴을 작성하면서 실시간으로 결과를 확인할 수 있어, 시행착오를 줄이고 올바른 정규식을 빠르게 완성할 수 있게 해줍니다. 특히 캡처 그룹을 사용할 때 각 그룹이 어떤 값을 캡처하는지 시각적으로 확인할 수 있어 매우 유용합니다.",
    troubleshooting: [
      {
        problem: "패턴이 아무것도 매치하지 않습니다",
        solution:
          "특수 문자(. * + ? ^ $ { } [ ] \\ | ( ))를 리터럴로 매치하려면 백슬래시로 이스케이프해야 합니다. 예: \\. (점 문자 매치)",
      },
      {
        problem: "전체 문자열이 아닌 일부만 매치됩니다",
        solution:
          "전체 문자열을 매치하려면 앵커를 사용하세요. ^는 문자열 시작, $는 문자열 끝을 의미합니다. 예: ^pattern$",
      },
      {
        problem: "대소문자를 무시하고 싶습니다",
        solution:
          "i 플래그를 활성화하세요. /pattern/i는 대소문자를 구분하지 않고 매치합니다.",
      },
      {
        problem: "줄바꿈을 포함한 텍스트가 매치되지 않습니다",
        solution:
          "기본적으로 .는 줄바꿈을 제외한 모든 문자와 매치됩니다. s 플래그를 사용하면 .가 줄바꿈도 매치합니다. 또는 [\\s\\S]를 사용하세요.",
      },
    ],
    advantages: [
      "실시간 피드백으로 빠른 패턴 개발",
      "캡처 그룹별 결과를 명확하게 표시",
      "자주 사용되는 패턴 예제 제공",
      "모든 JavaScript 정규식 플래그 지원",
      "Magic Share로 팀원과 정규식 공유",
      "회원가입 없이 무료로 무제한 사용",
    ],
    useCases: [
      "이메일, 전화번호, URL 형식 검증",
      "로그 파일 분석 및 데이터 추출",
      "텍스트 전처리 및 데이터 클렌징",
      "코드에서 특정 패턴 찾기",
      "사용자 입력 유효성 검사 패턴 개발",
      "문자열 치환 패턴 테스트",
    ],
  },

  "meta-generator": {
    whatIs:
      "Meta Tag Generator는 SEO에 필요한 메타 태그, Open Graph 태그, Twitter Card 태그를 쉽게 생성하는 도구입니다.",
    howToUse:
      "제목, 설명, URL, 이미지 등의 정보를 입력하면 HTML 메타 태그 코드가 자동으로 생성됩니다. 복사하여 HTML head에 붙여넣으세요.",
    features: [
      "기본 메타 태그 생성",
      "Open Graph 태그 생성",
      "Twitter Card 태그 생성",
      "실시간 미리보기",
    ],
    faq: [
      {
        q: "필수 태그는 무엇인가요?",
        a: "최소한 title, description, og:title, og:description을 권장합니다.",
      },
      {
        q: "이미지 크기 권장 사항은?",
        a: "Open Graph는 1200x630, Twitter Card는 1200x600 픽셀을 권장합니다.",
      },
    ],
    whyNeeded:
      "메타 태그는 검색 엔진 결과와 소셜 미디어 공유 시 사이트가 어떻게 표시되는지 결정합니다. 제대로 설정하지 않으면 검색 결과에 '설명 없음'이 표시되거나, Facebook/Twitter 공유 시 이미지가 누락될 수 있습니다. Meta Tag Generator는 SEO와 소셜 공유에 최적화된 태그를 쉽게 생성합니다.",
    troubleshooting: [
      {
        problem: "공유 시 이전 이미지가 표시됩니다",
        solution:
          "Facebook, Twitter 등은 메타 정보를 캐싱합니다. Facebook Sharing Debugger나 Twitter Card Validator에서 URL을 재크롤링하세요.",
      },
      {
        problem: "OG 이미지가 잘려서 표시됩니다",
        solution:
          "Open Graph 이미지는 1200x630 비율을 권장합니다. 이미지 중앙에 중요한 내용을 배치하세요. 각 플랫폼마다 크롭 방식이 다릅니다.",
      },
      {
        problem: "Twitter에서 카드가 표시되지 않습니다",
        solution:
          "twitter:card 메타 태그가 필요합니다. 'summary' 또는 'summary_large_image'를 지정하세요. Twitter Card Validator로 검증할 수 있습니다.",
      },
    ],
    advantages: [
      "SEO 필수 메타 태그 자동 생성 (title, description, keywords)",
      "Open Graph 태그로 Facebook, LinkedIn 등 소셜 공유 최적화",
      "Twitter Card 태그로 트위터 공유 시 미리보기 최적화",
      "필수 태그 누락 방지를 위한 체크리스트",
      "생성된 HTML 코드 즉시 복사",
      "실시간 미리보기로 소셜 공유 시 표시 확인",
    ],
    useCases: [
      "새 웹사이트 출시 시 SEO 메타 태그 설정",
      "블로그 포스트의 소셜 미디어 공유 최적화",
      "랜딩 페이지의 검색 결과 스니펫 최적화",
      "마케팅 캠페인 페이지의 소셜 카드 설정",
      "이커머스 제품 페이지 SEO 설정",
      "포트폴리오 사이트의 소셜 미리보기 커스터마이징",
    ],
  },

  "curl-builder": {
    whatIs:
      "cURL Builder는 HTTP 요청을 시각적으로 구성하고 cURL 명령어를 생성하는 도구입니다. 복잡한 API 호출도 쉽게 만들 수 있습니다.",
    howToUse:
      "URL, HTTP 메서드, 헤더, 요청 본문 등을 입력합니다. 생성된 cURL 명령어를 복사하여 터미널에서 실행할 수 있습니다. 기존 cURL 명령을 붙여넣어 파싱할 수도 있습니다.",
    features: [
      "GET/POST/PUT/DELETE 등 메서드 지원",
      "헤더 및 인증 설정",
      "JSON/Form/Raw 본문 지원",
      "cURL 명령어 Import/Export",
    ],
    faq: [
      {
        q: "cURL 명령어를 직접 실행할 수 있나요?",
        a: "아니요, 명령어 생성만 지원합니다. 터미널에서 실행하세요.",
      },
      {
        q: "파일 업로드도 지원하나요?",
        a: "multipart/form-data 형식은 현재 지원하지 않습니다.",
      },
    ],
    whyNeeded:
      'cURL은 API 테스트와 디버깅의 표준 도구지만, 복잡한 명령어 옵션을 외우기 어렵습니다. \'curl -X POST -H "Content-Type: application/json" -d \'{"key":"value"}\' URL\' 같은 명령어를 수동으로 작성하면 따옴표 처리나 옵션 순서에서 실수하기 쉽습니다. cURL Builder는 GUI로 요청을 구성하고 올바른 명령어를 생성합니다.',
    troubleshooting: [
      {
        problem: "생성된 명령어가 터미널에서 오류가 납니다",
        solution:
          "Windows CMD와 PowerShell은 따옴표 처리가 다릅니다. Linux/Mac용 명령어와 Windows용 명령어 형식이 다르니 운영체제에 맞게 선택하세요.",
      },
      {
        problem: "JSON 본문에서 따옴표 오류가 발생합니다",
        solution:
          "JSON 내부의 따옴표가 제대로 이스케이프되었는지 확인하세요. 단일 따옴표로 감싸고 내부에 이중 따옴표를 사용하거나, -d @file.json으로 파일에서 읽어오세요.",
      },
      {
        problem: "인증이 작동하지 않습니다",
        solution:
          "Basic Auth는 -u username:password, Bearer Token은 -H 'Authorization: Bearer TOKEN'을 사용하세요. 토큰에 특수문자가 있으면 따옴표로 감싸세요.",
      },
    ],
    advantages: [
      "복잡한 cURL 옵션을 GUI로 쉽게 구성",
      "GET, POST, PUT, DELETE, PATCH 등 모든 HTTP 메서드 지원",
      "헤더, 쿠키, 인증 정보 편리하게 추가",
      "JSON, Form, Raw 등 다양한 본문 형식 지원",
      "기존 cURL 명령어를 붙여넣어 편집 가능",
      "Windows/Linux/Mac 플랫폼별 명령어 형식 제공",
    ],
    useCases: [
      "REST API 엔드포인트 테스트 및 디버깅",
      "Webhook 요청 시뮬레이션",
      "OAuth 토큰 요청 구성",
      "API 문서용 cURL 예제 생성",
      "팀원과 API 호출 방법 공유",
      "Postman 컬렉션 대신 터미널 명령어 생성",
    ],
  },

  "svg-optimizer": {
    whatIs:
      "SVG Optimizer는 SVG 파일을 최적화하여 파일 크기를 줄이는 도구입니다. 불필요한 메타데이터와 중복 요소를 제거합니다.",
    howToUse:
      "SVG 코드를 붙여넣거나 파일을 업로드합니다. 최적화 옵션을 선택하고 실행하면 압축된 SVG가 생성됩니다. 압축률과 크기 변화를 확인할 수 있습니다.",
    features: [
      "메타데이터 제거",
      "경로 최적화",
      "중복 요소 병합",
      "압축률 표시",
    ],
    faq: [
      {
        q: "최적화 후 SVG가 깨지나요?",
        a: "시각적 품질은 유지됩니다. 필요에 따라 최적화 옵션을 조절하세요.",
      },
      {
        q: "어느 정도 압축되나요?",
        a: "SVG에 따라 다르지만, 일반적으로 20-50% 크기 감소가 가능합니다.",
      },
    ],
    whyNeeded:
      "디자인 도구(Figma, Illustrator, Sketch)에서 내보낸 SVG에는 편집용 메타데이터, 중복 그룹, 불필요한 속성이 포함됩니다. 이런 정보는 브라우저 렌더링에 필요 없지만 파일 크기를 늘립니다. 특히 아이콘 시스템이나 로고처럼 반복 사용되는 SVG는 최적화로 페이지 로드 시간을 크게 줄일 수 있습니다.",
    troubleshooting: [
      {
        problem: "최적화 후 SVG가 깨져 보입니다",
        solution:
          "일부 옵션(특히 경로 병합, 도형 변환)이 복잡한 SVG를 손상시킬 수 있습니다. 보수적인 옵션부터 시작하고 점진적으로 최적화 수준을 높이세요.",
      },
      {
        problem: "색상이 변경되었습니다",
        solution:
          "색상 단축 옵션이 활성화되어 있으면 #ffffff → #fff로 변환됩니다. 특정 색상 값이 필요하면 해당 옵션을 비활성화하세요.",
      },
      {
        problem: "애니메이션이 작동하지 않습니다",
        solution:
          "일부 최적화 옵션이 SMIL 애니메이션이나 CSS 애니메이션에 필요한 ID/클래스를 제거할 수 있습니다. ID/클래스 유지 옵션을 확인하세요.",
      },
    ],
    advantages: [
      "Figma, Illustrator, Sketch 등에서 내보낸 SVG 즉시 최적화",
      "불필요한 메타데이터(편집기 정보, 주석) 제거",
      "경로 최적화로 좌표 정밀도 조절",
      "평균 20-50% 파일 크기 감소",
      "원본 대비 압축률 즉시 확인",
      "로컬 처리로 민감한 디자인 자산 보호",
    ],
    useCases: [
      "웹사이트 아이콘 시스템 최적화",
      "로고 및 브랜드 자산 웹 배포 준비",
      "인라인 SVG 삽입 시 코드량 감소",
      "SVG 스프라이트 시트 최적화",
      "이메일 템플릿용 경량화된 SVG 생성",
      "React/Vue 컴포넌트로 변환 전 최적화",
    ],
  },

  "css-to-tailwind": {
    whatIs:
      "CSS to Tailwind는 일반 CSS 속성을 Tailwind CSS 클래스로 변환하는 도구입니다. Tailwind 마이그레이션이나 학습에 유용합니다.",
    howToUse:
      "CSS 코드를 입력하면 해당하는 Tailwind 클래스가 표시됩니다. 지원되지 않는 속성은 별도로 표시되어 수동 처리가 필요한 부분을 확인할 수 있습니다.",
    features: [
      "CSS → Tailwind 클래스 변환",
      "지원/미지원 속성 구분",
      "일반적인 CSS 패턴 지원",
      "클립보드 복사",
    ],
    faq: [
      {
        q: "모든 CSS 속성을 변환할 수 있나요?",
        a: "Tailwind에서 지원하는 속성만 변환됩니다. 커스텀 값은 수동 설정이 필요할 수 있습니다.",
      },
      {
        q: "복잡한 CSS도 변환되나요?",
        a: "단일 속성 변환은 잘 되지만, 복합 선택자나 미디어 쿼리는 수동 처리가 필요합니다.",
      },
    ],
    whyNeeded:
      "Tailwind CSS로 마이그레이션하거나 처음 배울 때, 'margin: 20px'가 'mx-5'인지 'm-5'인지 헷갈립니다. Tailwind의 유틸리티 클래스 체계를 완전히 익히기 전까지는 CSS 속성에 해당하는 클래스를 찾는 데 시간이 걸립니다. CSS to Tailwind는 이 변환을 자동화하여 학습 곡선을 줄여줍니다.",
    troubleshooting: [
      {
        problem: "변환된 클래스가 Tailwind에서 작동하지 않습니다",
        solution:
          "커스텀 값(예: margin: 13px)은 Tailwind 기본 스케일에 없을 수 있습니다. tailwind.config.js에서 확장하거나 임의 값(m-[13px])을 사용하세요.",
      },
      {
        problem: "미디어 쿼리가 변환되지 않습니다",
        solution:
          "Tailwind는 반응형을 sm:, md:, lg: 접두사로 처리합니다. CSS 미디어 쿼리는 수동으로 해당 접두사 클래스로 변환해야 합니다.",
      },
      {
        problem: "hover/focus 상태가 변환되지 않습니다",
        solution:
          "의사 클래스(:hover, :focus)는 Tailwind의 hover:, focus: 접두사로 변환해야 합니다. 현재 자동 변환은 기본 속성에 집중합니다.",
      },
    ],
    advantages: [
      "CSS 속성을 대응하는 Tailwind 클래스로 즉시 변환",
      "변환 가능/불가능 속성을 명확하게 구분",
      "Tailwind 클래스 학습 도구로 활용",
      "기존 CSS 프로젝트의 Tailwind 마이그레이션 가속화",
      "복잡한 속성 값도 가장 근접한 클래스 제안",
      "실시간 변환으로 빠른 작업",
    ],
    useCases: [
      "Bootstrap이나 순수 CSS 프로젝트를 Tailwind로 마이그레이션",
      "Tailwind 클래스 이름 학습 및 참조",
      "디자이너가 제공한 CSS 스펙을 Tailwind로 변환",
      "기존 스타일 코드를 Tailwind 컴포넌트로 리팩토링",
      "Figma Dev Mode CSS를 Tailwind로 변환",
      "CSS 프레임워크 간 스타일 이식",
    ],
  },

  "prettier-playground": {
    whatIs:
      "Prettier Playground는 다양한 언어의 코드를 Prettier로 포맷팅하는 도구입니다. JavaScript, TypeScript, CSS, HTML, JSON, Markdown 등을 지원합니다.",
    howToUse:
      "언어를 선택하고 코드를 입력합니다. Prettier 옵션(탭 크기, 따옴표 스타일 등)을 조절하면 실시간으로 포맷팅된 결과가 표시됩니다. .prettierrc 파일도 생성할 수 있습니다.",
    features: [
      "JavaScript, TypeScript, JSON, HTML, CSS, Markdown 지원",
      "모든 Prettier 옵션 커스터마이징",
      ".prettierrc 설정 생성",
      "실시간 포맷팅",
    ],
    faq: [
      {
        q: "어떤 언어를 지원하나요?",
        a: "JavaScript, TypeScript, JSON, HTML, CSS, Markdown, YAML, GraphQL을 지원합니다.",
      },
      {
        q: "Prettier 버전은?",
        a: "최신 Prettier Standalone 버전을 사용합니다.",
      },
    ],
    whyNeeded:
      "팀에서 코드 스타일을 통일하려면 Prettier 설정이 필요합니다. 하지만 100개가 넘는 옵션 중에서 tabWidth, printWidth, singleQuote, trailingComma 등 어떤 조합이 좋을지 결정하기 어렵습니다. Prettier Playground는 옵션을 실시간으로 테스트하며 팀에 맞는 .prettierrc 설정을 찾을 수 있게 해줍니다.",
    troubleshooting: [
      {
        problem: "포맷팅 결과가 예상과 다릅니다",
        solution:
          "언어 선택이 올바른지 확인하세요. 특히 JSX가 포함된 코드는 JavaScript가 아닌 JSX/TSX 파서를 선택해야 합니다.",
      },
      {
        problem: "특정 코드 스타일이 적용되지 않습니다",
        solution:
          "Prettier는 '의견이 강한' 포맷터로, 일부 스타일은 변경할 수 없습니다. Prettier의 철학은 논쟁 가능한 옵션을 최소화하는 것입니다.",
      },
      {
        problem: "파싱 오류가 발생합니다",
        solution:
          "구문 오류가 있는 코드는 포맷팅할 수 없습니다. 먼저 코드의 문법 오류를 수정하세요. 괄호 불일치나 세미콜론 누락이 흔한 원인입니다.",
      },
    ],
    advantages: [
      "JavaScript, TypeScript, CSS, HTML, JSON, Markdown, YAML, GraphQL 지원",
      "모든 Prettier 옵션을 GUI로 조절하며 실시간 확인",
      ".prettierrc 설정 파일 자동 생성",
      "최신 Prettier Standalone 버전 사용",
      "팀 코드 스타일 가이드 정립에 활용",
      "브라우저에서 바로 실행, 설치 불필요",
    ],
    useCases: [
      "프로젝트 .prettierrc 설정 최적화",
      "코드 리뷰 전 포맷팅 통일",
      "팀 코딩 컨벤션 논의 시 실시간 데모",
      "온라인 코드 공유 전 정리",
      "레거시 코드베이스 스타일 통일 계획",
      "Prettier 옵션 학습 및 실험",
    ],
  },

  "json-to-typescript": {
    whatIs:
      "JSON to TypeScript는 JSON 데이터를 TypeScript 인터페이스나 타입 정의로 변환하는 도구입니다. API 응답에서 타입 안전한 코드를 즉시 생성할 수 있습니다.",
    howToUse:
      "JSON 데이터를 붙여넣고 루트 타입 이름, interface/type 선택, 옵셔널 속성 여부 등의 옵션을 설정하세요. 생성된 TypeScript 코드를 복사하여 프로젝트에 사용하세요.",
    features: [
      "인터페이스 및 타입 별칭 출력",
      "옵셔널 속성 지원",
      "중첩 객체 자동 처리",
      "export 문 옵션",
    ],
    faq: [
      {
        q: "interface와 type 중 무엇을 사용해야 하나요?",
        a: "객체에는 확장 가능한 interface가 선호됩니다. type은 유니온과 복잡한 타입에 적합합니다.",
      },
      {
        q: "중첩된 JSON도 처리하나요?",
        a: "네, 중첩된 객체는 자동으로 별도의 인터페이스/타입으로 변환됩니다.",
      },
    ],
    whyNeeded:
      "TypeScript 프로젝트에서 API 응답이나 JSON 데이터의 타입을 수동으로 작성하는 것은 지루하고 오류가 발생하기 쉽습니다. 특히 중첩된 객체나 배열이 포함된 복잡한 JSON 구조에서는 더욱 그렇습니다. JSON to TypeScript는 실제 데이터에서 정확한 타입 정의를 즉시 생성하여 타입 안전성을 확보하고 개발 속도를 높입니다.",
    troubleshooting: [
      {
        problem: "null 값이 포함된 속성의 타입이 잘못됩니다",
        solution:
          "JSON에서 null은 실제 타입이 아닙니다. null이 있는 필드는 실제 데이터 타입 | null로 표현해야 하며, 여러 샘플 데이터를 확인하여 올바른 타입을 결정하세요.",
      },
      {
        problem: "배열이 빈 경우 타입이 unknown[]로 생성됩니다",
        solution:
          "빈 배열에서는 요소 타입을 추론할 수 없습니다. 배열에 데이터가 있는 샘플 JSON을 사용하거나 수동으로 타입을 지정하세요.",
      },
      {
        problem: "숫자가 문자열로 인식됩니다",
        solution:
          'JSON에서 따옴표로 감싼 숫자("123")는 문자열입니다. 실제 number 타입이 필요하면 JSON에서 따옴표를 제거하거나 생성된 타입을 수정하세요.',
      },
    ],
    advantages: [
      "복잡한 중첩 객체도 자동으로 별도 인터페이스로 분리",
      "interface와 type alias 중 선택 가능",
      "옵셔널 속성(?) 자동 또는 수동 지정",
      "export 문 자동 추가 옵션",
      "실제 API 응답에서 즉시 타입 생성",
      "TypeScript 프로젝트 타입 안전성 향상",
    ],
    useCases: [
      "REST API 응답에서 타입 정의 생성",
      "GraphQL 응답 타입 정의",
      "JSON 설정 파일의 TypeScript 타입 생성",
      "외부 데이터 소스(Firebase, Supabase 등) 타입 정의",
      "Mock 데이터에서 인터페이스 생성",
      "레거시 JS 프로젝트의 TS 마이그레이션 지원",
    ],
  },

  "css-minifier": {
    whatIs:
      "CSS Minifier는 공백, 주석을 제거하고 구문을 최적화하여 CSS 코드를 압축하는 도구입니다. 더 빠른 페이지 로드를 위해 파일 크기를 줄일 수 있습니다.",
    howToUse:
      "CSS 코드를 붙여넣고 Minify 버튼을 클릭하세요. 주석 제거, 색상 단축, 선택자 병합 등의 옵션을 설정할 수 있습니다. 결과를 복사하거나 다운로드하세요.",
    features: [
      "주석 및 공백 제거",
      "색상 값 단축 (#ffffff → #fff)",
      "중복 선택자 병합",
      "Beautify 기능 포함",
    ],
    faq: [
      {
        q: "파일 크기를 얼마나 줄일 수 있나요?",
        a: "원본 CSS 포맷팅과 주석에 따라 일반적으로 20-60% 감소합니다.",
      },
      {
        q: "압축이 CSS를 손상시키나요?",
        a: "아니요, 압축은 기능을 유지하면서 불필요한 문자만 제거합니다.",
      },
    ],
    whyNeeded:
      "프로덕션 환경에서는 CSS 파일 크기가 페이지 로드 속도에 직접 영향을 미칩니다. 개발 중 작성한 주석, 들여쓰기, 공백은 가독성에 필요하지만 브라우저 렌더링에는 불필요합니다. CSS Minifier는 이러한 불필요한 문자를 제거하여 파일 크기를 20-60% 줄여 웹 성능을 향상시킵니다.",
    troubleshooting: [
      {
        problem: "압축 후 스타일이 깨졌습니다",
        solution:
          "CSS 자체에 구문 오류가 있었을 수 있습니다. 압축 전 원본 CSS가 유효한지 확인하세요. 누락된 중괄호나 세미콜론이 흔한 원인입니다.",
      },
      {
        problem: "특정 주석이 유지되어야 합니다",
        solution:
          "/*! 로 시작하는 주석은 라이선스 보존용으로 유지됩니다. 중요한 주석에 느낌표를 추가하세요.",
      },
      {
        problem: "Source Map이 필요합니다",
        solution:
          "디버깅을 위해 압축 전 원본을 별도로 보관하세요. 프로덕션 빌드 도구에서는 Source Map을 자동으로 생성합니다.",
      },
    ],
    advantages: [
      "불필요한 공백, 줄바꿈, 주석 완전 제거",
      "색상 값 단축 (#ffffff → #fff, rgb(0,0,0) → #000)",
      "중복 선택자 및 속성 병합",
      "평균 20-60% 파일 크기 감소",
      "Beautify 모드로 압축된 CSS 다시 정리 가능",
      "실시간 압축률 표시",
    ],
    useCases: [
      "프로덕션 배포 전 CSS 최적화",
      "워드프레스/웹사이트 빌더 커스텀 CSS 압축",
      "이메일 템플릿의 인라인 CSS 축소",
      "CDN 배포용 CSS 파일 준비",
      "빌드 도구 없이 빠르게 CSS 압축",
      "타사 CSS 라이브러리 경량화",
    ],
  },

  "text-case-converter": {
    whatIs:
      "Text Case Converter는 camelCase, snake_case, kebab-case 등 다양한 명명 규칙으로 텍스트를 변환하는 도구입니다.",
    howToUse:
      "텍스트를 입력하면 지원되는 모든 케이스로 즉시 변환됩니다. 원하는 결과를 클릭하여 클립보드에 복사하세요.",
    features: [
      "12가지 이상의 케이스 포맷 지원",
      "실시간 변환",
      "원클릭 복사",
      "프로그래밍 명명 규칙 지원",
    ],
    faq: [
      {
        q: "어떤 케이스가 지원되나요?",
        a: "camelCase, PascalCase, snake_case, kebab-case, CONSTANT_CASE, dot.case, path/case 등이 지원됩니다.",
      },
      {
        q: "각 케이스는 언제 사용해야 하나요?",
        a: "JavaScript 변수에는 camelCase, Python에는 snake_case, CSS 클래스와 URL에는 kebab-case를 사용하세요.",
      },
    ],
    whyNeeded:
      "프로그래밍에서는 언어, 프레임워크, 컨텍스트에 따라 다른 명명 규칙을 사용합니다. JavaScript 함수명(camelCase)을 Python으로 포팅할 때는 snake_case로, CSS 클래스로 사용할 때는 kebab-case로 변환해야 합니다. 이런 변환을 수동으로 하면 시간이 오래 걸리고 실수하기 쉽습니다.",
    troubleshooting: [
      {
        problem: "특수문자가 포함된 텍스트가 잘못 변환됩니다",
        solution:
          "케이스 변환은 알파벳과 숫자를 기준으로 합니다. 특수문자(@, #, $ 등)는 구분자로 처리되거나 제거될 수 있습니다. 가능하면 특수문자 없이 입력하세요.",
      },
      {
        problem: "약어(API, URL 등)가 분리됩니다",
        solution:
          "연속된 대문자는 개별 단어로 인식될 수 있습니다. 'APIEndpoint'는 'api_endpoint' 또는 'api-endpoint'로 변환됩니다. 이는 대부분의 케이스 변환기의 표준 동작입니다.",
      },
      {
        problem: "숫자가 포함된 이름이 이상하게 변환됩니다",
        solution:
          "숫자는 일반적으로 단어 구분자로 취급되지 않습니다. 'value2string'은 'value2String'(PascalCase)이 아닌 'value2string'으로 유지될 수 있습니다.",
      },
    ],
    advantages: [
      "12가지 이상의 케이스 포맷 동시 변환",
      "camelCase, PascalCase, snake_case, SCREAMING_SNAKE_CASE 지원",
      "kebab-case, dot.case, path/case, Title Case 등 다양한 포맷",
      "입력 즉시 모든 변환 결과 표시",
      "원클릭 클립보드 복사",
      "프로그래밍 언어별 명명 규칙 참조 가이드",
    ],
    useCases: [
      "JavaScript와 Python 코드 간 변수명 변환",
      "데이터베이스 컬럼명(snake_case)을 API 응답(camelCase)으로 변환",
      "CSS 클래스명(kebab-case) 생성",
      "환경 변수명(SCREAMING_SNAKE_CASE) 작성",
      "URL 슬러그 생성",
      "일관된 코딩 컨벤션 유지",
    ],
  },

  "video-compressor": {
    whatIs:
      "Video Compressor는 FFmpeg.wasm을 사용하여 브라우저에서 직접 비디오 파일을 압축하는 도구입니다. 모든 처리가 100% 로컬에서 이루어지므로 파일이 서버로 전송되지 않아 안전합니다. H.264, VP9 등 다양한 코덱을 지원하며, 해상도, 품질, 비트레이트를 자유롭게 조정할 수 있습니다.",
    howToUse:
      "비디오 파일을 드래그 앤 드롭하거나 선택하세요. 품질 프리셋(고품질, 중간, 저품질)을 선택하거나 CRF, 해상도 등을 직접 설정한 후 압축 버튼을 클릭합니다. 압축이 완료되면 결과를 미리보고 다운로드할 수 있습니다.",
    features: [
      "FFmpeg.wasm 기반 고성능 압축",
      "H.264, VP9 등 다양한 코덱 지원",
      "해상도 조정 (720p, 1080p, 4K)",
      "품질 설정 (CRF) 및 비트레이트 제어",
      "오디오 제거 옵션",
      "웹 스트리밍 최적화 (Fast Start)",
      "100% 브라우저 내 처리 - 파일 업로드 없음",
    ],
    faq: [
      {
        q: "비디오 파일이 서버로 전송되나요?",
        a: "아니요, 모든 처리는 WebAssembly를 통해 브라우저 내에서 이루어집니다. 파일은 절대 서버로 전송되지 않으므로 민감한 비디오도 안전하게 압축할 수 있습니다.",
      },
      {
        q: "어떤 포맷을 지원하나요?",
        a: "입력은 MP4, WebM, MOV, AVI, MKV 등 주요 포맷을 지원하며, 출력은 MP4(H.264), WebM(VP9) 포맷으로 변환할 수 있습니다. 최대 파일 크기는 500MB입니다.",
      },
      {
        q: "CRF 값은 무엇인가요?",
        a: "CRF(Constant Rate Factor)는 품질을 제어하는 값입니다. 값이 낮을수록(18-23) 고품질이지만 파일이 커지고, 높을수록(28-35) 저품질이지만 파일이 작아집니다. 일반적으로 23-28 사이를 권장합니다.",
      },
    ],
    whyNeeded:
      "대용량 비디오 파일을 공유하거나 업로드할 때 압축이 필요합니다. 기존 온라인 압축 서비스는 파일을 서버로 업로드해야 하지만, 이 도구는 브라우저에서 직접 처리하므로 프라이버시가 보장됩니다. 로컬 소프트웨어 설치 없이도 전문적인 비디오 압축이 가능합니다.",
    troubleshooting: [
      {
        problem: "FFmpeg 로딩이 오래 걸립니다",
        solution:
          "FFmpeg.wasm 코어 파일(약 30MB)을 처음 로드할 때 시간이 걸릴 수 있습니다. 인터넷 속도에 따라 1-3분 정도 소요됩니다. 로드가 완료되면 세션 동안 재사용됩니다.",
      },
      {
        problem: "압축 중 브라우저가 느려집니다",
        solution:
          "비디오 압축은 CPU 집약적인 작업입니다. 다른 탭을 닫고, 가능하면 Chrome이나 Edge 같은 최신 브라우저를 사용하세요. 대용량 파일은 시간이 더 걸릴 수 있습니다.",
      },
      {
        problem: "SharedArrayBuffer 오류가 발생합니다",
        solution:
          "이 도구는 멀티스레딩을 위해 SharedArrayBuffer가 필요합니다. 일부 브라우저에서는 보안 헤더 설정으로 인해 제한될 수 있습니다. Chrome 최신 버전 사용을 권장합니다.",
      },
    ],
    advantages: [
      "100% 브라우저 기반 - 설치 불필요",
      "완전한 프라이버시 - 파일이 서버로 전송되지 않음",
      "다양한 코덱 및 포맷 지원",
      "세밀한 품질 설정 가능",
      "실시간 압축 진행률 표시",
      "압축 결과 미리보기",
    ],
    useCases: [
      "소셜 미디어 업로드용 비디오 압축",
      "이메일 첨부용 파일 크기 줄이기",
      "웹사이트용 비디오 최적화",
      "저장 공간 절약",
      "대역폭 제한 환경에서의 비디오 공유",
      "민감한 비디오의 안전한 압축",
    ],
  },
  "pdf-toolkit": {
    whatIs:
      "PDF Toolkit은 PDF 파일을 브라우저에서 직접 병합, 분할, 압축할 수 있는 올인원 도구입니다. pdf-lib 라이브러리를 기반으로 모든 처리가 100% 클라이언트 사이드에서 이루어지므로 파일이 서버로 전송되지 않아 안전합니다.",
    howToUse:
      "병합: 여러 PDF 파일을 드래그 앤 드롭으로 추가하고 순서를 조정한 후 병합 버튼을 클릭합니다. 분할: PDF 파일을 선택하고 모든 페이지 추출 또는 특정 페이지 범위를 지정하여 분할합니다. 압축: PDF 파일을 선택하고 메타데이터 제거 옵션을 설정한 후 압축합니다.",
    features: [
      "PDF 병합 - 여러 파일을 하나로 합치기",
      "PDF 분할 - 페이지별 또는 범위별 분리",
      "PDF 압축 - 파일 크기 최적화",
      "드래그 앤 드롭으로 파일 순서 변경",
      "100% 브라우저 내 처리 - 서버 업로드 없음",
      "메타데이터 제거 옵션",
    ],
    faq: [
      {
        q: "PDF 파일이 서버로 전송되나요?",
        a: "아니요, 모든 처리는 브라우저 내에서 이루어집니다. 파일은 절대 서버로 전송되지 않으므로 민감한 문서도 안전하게 처리할 수 있습니다.",
      },
      {
        q: "몇 개의 PDF까지 병합할 수 있나요?",
        a: "브라우저 메모리가 허용하는 범위 내에서 여러 파일을 병합할 수 있습니다. 일반적으로 수십 개의 일반 PDF 문서는 문제없이 처리됩니다.",
      },
      {
        q: "암호로 보호된 PDF도 처리할 수 있나요?",
        a: "암호화되지 않은 PDF만 처리할 수 있습니다. 암호로 보호된 PDF는 먼저 암호를 해제해야 합니다.",
      },
    ],
    whyNeeded:
      "PDF 문서를 합치거나 나누는 작업은 업무에서 자주 필요합니다. 기존 도구들은 소프트웨어 설치가 필요하거나 파일을 서버에 업로드해야 하지만, 이 도구는 브라우저에서 직접 처리하여 프라이버시와 편의성을 모두 제공합니다.",
    troubleshooting: [
      {
        problem: "큰 PDF 파일 처리가 느립니다",
        solution:
          "대용량 PDF는 처리 시간이 길어질 수 있습니다. 브라우저 탭을 닫지 말고 처리가 완료될 때까지 기다려주세요.",
      },
      {
        problem: "일부 PDF가 제대로 열리지 않습니다",
        solution:
          "일부 특수한 형식이나 손상된 PDF는 처리가 어려울 수 있습니다. 다른 PDF 리더에서 파일이 정상적으로 열리는지 확인해보세요.",
      },
    ],
    advantages: [
      "100% 브라우저 기반 - 설치 불필요",
      "완전한 프라이버시 - 파일이 서버로 전송되지 않음",
      "병합, 분할, 압축을 한 곳에서",
      "직관적인 드래그 앤 드롭 인터페이스",
      "실시간 진행률 표시",
    ],
    useCases: [
      "여러 문서를 하나의 PDF로 통합",
      "대용량 PDF에서 필요한 페이지만 추출",
      "이메일 첨부용 PDF 파일 크기 줄이기",
      "문서 공유를 위한 최적화",
      "민감한 문서의 안전한 처리",
    ],
  },
  "ocr-scanner": {
    whatIs:
      "OCR Scanner는 이미지에서 텍스트를 추출하는 광학 문자 인식(Optical Character Recognition) 도구입니다. Tesseract.js 엔진을 기반으로 한국어, 영어, 일본어를 포함한 다국어 인식을 지원하며, 모든 처리가 브라우저에서 이루어져 이미지가 서버로 전송되지 않습니다.",
    howToUse:
      "이미지 파일을 드래그 앤 드롭하거나 클릭하여 업로드합니다. 인식할 언어를 선택하고 'Extract Text' 버튼을 클릭하면 이미지에서 텍스트가 추출됩니다. 추출된 텍스트는 복사하거나 텍스트 파일로 다운로드할 수 있습니다.",
    features: [
      "한국어, 영어, 일본어 및 다국어 혼합 인식 지원",
      "100% 브라우저 내 처리 - 이미지가 서버로 전송되지 않음",
      "PNG, JPEG, WebP, BMP, GIF 이미지 포맷 지원",
      "실시간 진행률 표시",
      "추출된 텍스트 복사 및 다운로드",
      "신뢰도 점수 표시",
    ],
    faq: [
      {
        q: "이미지가 서버에 업로드되나요?",
        a: "아니요, 모든 OCR 처리는 브라우저 내에서 Tesseract.js를 통해 이루어집니다. 이미지는 절대 서버로 전송되지 않아 민감한 문서도 안전하게 처리할 수 있습니다.",
      },
      {
        q: "어떤 언어를 지원하나요?",
        a: "한국어, 영어, 일본어를 지원합니다. 단일 언어 또는 여러 언어가 혼합된 이미지도 인식할 수 있습니다.",
      },
      {
        q: "손글씨도 인식할 수 있나요?",
        a: "Tesseract는 주로 인쇄된 텍스트에 최적화되어 있습니다. 손글씨는 깔끔하고 명확한 경우에만 일부 인식될 수 있습니다.",
      },
      {
        q: "처리 시간이 얼마나 걸리나요?",
        a: "이미지 크기와 복잡도에 따라 다르지만, 일반적인 문서 이미지는 10-30초 내에 처리됩니다. 첫 번째 인식 시 언어 데이터 로딩으로 추가 시간이 소요될 수 있습니다.",
      },
    ],
    whyNeeded:
      "스캔한 문서, 스크린샷, 사진에서 텍스트를 직접 타이핑하는 것은 시간이 많이 걸리고 오류가 발생하기 쉽습니다. OCR Scanner를 사용하면 이미지에서 텍스트를 자동으로 추출하여 편집, 검색, 번역에 활용할 수 있습니다. 또한 서버 업로드 없이 처리되어 민감한 문서도 안심하고 사용할 수 있습니다.",
    troubleshooting: [
      {
        problem: "텍스트 인식률이 낮습니다",
        solution:
          "이미지 품질이 좋을수록 인식률이 높아집니다. 고해상도 이미지를 사용하고, 텍스트가 기울어지지 않고 명확하게 보이는지 확인하세요. 또한 올바른 언어를 선택했는지 확인하세요.",
      },
      {
        problem: "처리 시간이 너무 오래 걸립니다",
        solution:
          "첫 번째 인식 시에는 언어 데이터를 다운로드해야 해서 시간이 더 걸립니다. 이후 같은 언어로 인식할 때는 더 빨라집니다. 매우 큰 이미지는 리사이징 후 시도해보세요.",
      },
      {
        problem: "특정 문자가 잘못 인식됩니다",
        solution:
          "비슷하게 생긴 문자(0과 O, l과 1 등)는 혼동될 수 있습니다. 결과를 확인하고 필요시 수동으로 수정하세요.",
      },
    ],
    advantages: [
      "100% 브라우저 기반 - 설치 불필요",
      "완전한 프라이버시 - 이미지가 서버로 전송되지 않음",
      "한/영/일 다국어 지원",
      "무료 무제한 사용",
      "오프라인에서도 사용 가능 (언어 데이터 캐시 후)",
    ],
    useCases: [
      "스캔된 문서에서 텍스트 추출",
      "스크린샷의 텍스트 복사",
      "책이나 매거진 페이지 디지털화",
      "외국어 텍스트 추출 및 번역 준비",
      "명함이나 영수증 정보 추출",
    ],
  },
  "schema-generator": {
    whatIs:
      "Schema Markup Generator는 웹사이트의 검색 엔진 최적화(SEO)를 위한 JSON-LD 형식의 구조화 데이터를 생성하는 도구입니다. Google, Bing 등 검색 엔진이 웹페이지의 콘텐츠를 더 잘 이해할 수 있도록 도와주며, 검색 결과에서 리치 스니펫(별점, 가격, FAQ 등)으로 표시될 수 있게 합니다.",
    howToUse:
      "스키마 타입을 선택하고(Article, Product, FAQ 등) 폼에 정보를 입력하면 실시간으로 JSON-LD 코드가 생성됩니다. 생성된 코드를 복사하여 웹페이지의 <head> 섹션에 추가하세요. 'Include script tag' 옵션을 켜면 <script> 태그가 포함된 완전한 코드를 얻을 수 있습니다.",
    features: [
      "10가지 스키마 타입 지원 (Article, Product, FAQ, HowTo, Organization, LocalBusiness, Person, Event, Recipe, Breadcrumb)",
      "실시간 JSON-LD 코드 생성",
      "Google Rich Results 호환 포맷",
      "스크립트 태그 포함/제외 옵션",
      "폼 데이터 리셋 기능",
      "100% 클라이언트 사이드 처리",
    ],
    faq: [
      {
        q: "JSON-LD란 무엇인가요?",
        a: "JSON-LD(JavaScript Object Notation for Linked Data)는 구조화 데이터를 표현하는 방법 중 하나입니다. Google이 권장하는 형식이며, 웹페이지 콘텐츠를 검색 엔진이 쉽게 이해할 수 있도록 합니다.",
      },
      {
        q: "구조화 데이터가 SEO에 어떻게 도움이 되나요?",
        a: "구조화 데이터를 추가하면 검색 엔진이 페이지 내용을 더 정확히 이해하고, 검색 결과에서 리치 스니펫(별점, 가격, 이미지 등)으로 표시될 가능성이 높아져 클릭률이 향상됩니다.",
      },
      {
        q: "생성된 코드를 어디에 추가하나요?",
        a: '생성된 JSON-LD 코드를 <script type="application/ld+json"> 태그 안에 넣고, 웹페이지의 <head> 섹션에 추가합니다. 본문(<body>)에 추가해도 작동하지만 <head>가 권장됩니다.',
      },
      {
        q: "여러 스키마를 한 페이지에 사용할 수 있나요?",
        a: "네, 한 페이지에 여러 종류의 구조화 데이터를 추가할 수 있습니다. 예를 들어 블로그 글에 Article 스키마와 Breadcrumb 스키마를 함께 사용할 수 있습니다.",
      },
    ],
    whyNeeded:
      "검색 엔진은 웹페이지의 HTML만으로는 콘텐츠의 의미를 완전히 이해하기 어렵습니다. 구조화 데이터를 추가하면 '이것은 제품이고, 가격은 얼마이며, 평점은 몇 점이다'와 같은 명확한 정보를 검색 엔진에 전달할 수 있습니다. 이를 통해 검색 결과에서 더 눈에 띄는 리치 스니펫이 표시되어 더 많은 클릭을 유도할 수 있습니다.",
    troubleshooting: [
      {
        problem: "Google에서 구조화 데이터를 인식하지 못합니다",
        solution:
          "Google의 Rich Results Test(https://search.google.com/test/rich-results)로 코드를 검증하세요. 필수 필드가 누락되었거나 형식이 잘못되었을 수 있습니다.",
      },
      {
        problem: "리치 스니펫이 검색 결과에 표시되지 않습니다",
        solution:
          "구조화 데이터를 추가해도 Google이 반드시 리치 스니펫을 표시하는 것은 아닙니다. 알고리즘에 따라 표시 여부가 결정되며, 페이지의 품질과 관련성도 영향을 미칩니다.",
      },
      {
        problem: "날짜 형식이 잘못되었습니다",
        solution:
          "날짜는 ISO 8601 형식(YYYY-MM-DD 또는 YYYY-MM-DDTHH:MM:SS)으로 입력해야 합니다. 도구에서 제공하는 날짜 선택기를 사용하면 올바른 형식이 자동으로 적용됩니다.",
      },
    ],
    advantages: [
      "10가지 주요 스키마 타입 지원",
      "직관적인 폼 인터페이스",
      "실시간 코드 생성 및 미리보기",
      "Google 권장 JSON-LD 형식",
      "무료 무제한 사용",
    ],
    useCases: [
      "블로그 글에 Article 스키마 추가",
      "제품 페이지에 Product 스키마로 가격/재고 표시",
      "FAQ 페이지에 질문/답변 구조화",
      "레시피 사이트에 Recipe 스키마로 조리법 마크업",
      "이벤트 페이지에 날짜/장소 정보 구조화",
      "로컬 비즈니스 정보 검색 최적화",
    ],
  },

  "headline-analyzer": {
    whatIs:
      "Headline Analyzer는 블로그 제목, 이메일 제목, 광고 카피 등 헤드라인의 효과를 분석하는 도구입니다. CoSchedule의 헤드라인 분석 방법론을 기반으로, 단어 밸런스(일반어, 희귀어, 감정어, 파워워드), 감정 점수, SEO 최적화 요소를 종합적으로 평가하여 0-100점의 점수와 A+ ~ F 등급을 제공합니다.",
    howToUse:
      "분석하고 싶은 헤드라인을 입력창에 입력하세요. 실시간으로 점수, 등급, 단어 분석, 감정 분석, SEO 요소가 표시됩니다. 예시 헤드라인 버튼을 클릭하면 참고할 수 있는 좋은 헤드라인을 불러올 수 있습니다.",
    features: [
      "0-100점 점수 및 A+ ~ F 등급 시스템",
      "단어 밸런스 분석 (일반어, 희귀어, 감정어, 파워워드)",
      "감정 분석 (긍정, 부정, 중립)",
      "SEO 요소 체크 (숫자, 괄호, 최적 길이)",
      "헤드라인 유형 자동 감지 (How-To, 리스티클, 질문 등)",
      "실시간 개선 제안",
    ],
    faq: [
      {
        q: "좋은 헤드라인 점수는 몇 점인가요?",
        a: "70점 이상이면 좋은 헤드라인입니다. 80점 이상은 매우 효과적이며, 60점 미만은 개선이 필요합니다. 감정어와 파워워드를 추가하면 점수를 높일 수 있습니다.",
      },
      {
        q: "파워워드(Power Words)란 무엇인가요?",
        a: "파워워드는 독자의 행동을 유도하는 강력한 단어들입니다. '무료', '즉시', '비밀', '검증된', '궁극의' 같은 단어들이 포함됩니다. 이런 단어를 적절히 사용하면 클릭률이 높아집니다.",
      },
      {
        q: "최적의 헤드라인 길이는?",
        a: "SEO 관점에서 50-60자가 이상적입니다. 너무 짧으면 정보가 부족하고, 너무 길면 검색 결과에서 잘립니다. 단어 수는 6-12개가 적당합니다.",
      },
      {
        q: "숫자가 헤드라인에 왜 좋은가요?",
        a: "숫자가 포함된 헤드라인(예: '10가지 방법')은 구체적이고 명확해 보여 더 많은 클릭을 받습니다. 특히 홀수와 7, 10 같은 숫자가 효과적입니다.",
      },
    ],
    whyNeeded:
      "온라인 콘텐츠의 80%는 헤드라인만 보고 클릭 여부가 결정됩니다. 아무리 좋은 내용이라도 헤드라인이 매력적이지 않으면 읽히지 않습니다. Headline Analyzer는 데이터 기반으로 헤드라인을 분석하여 감이 아닌 과학적 방법으로 더 효과적인 제목을 작성할 수 있게 도와줍니다.",
    troubleshooting: [
      {
        problem: "점수가 너무 낮게 나옵니다",
        solution:
          "감정어나 파워워드를 추가해보세요. 예를 들어 'Tips'를 'Proven Tips'로, 'Ways'를 'Amazing Ways'로 바꾸면 점수가 올라갑니다.",
      },
      {
        problem: "어떤 단어가 감정어인지 모르겠습니다",
        solution:
          "분석 결과에서 감정어와 파워워드 목록을 확인할 수 있습니다. 'amazing', 'incredible', 'shocking' 같은 강한 형용사가 감정어에 해당합니다.",
      },
      {
        problem: "한글 헤드라인도 분석할 수 있나요?",
        solution:
          "현재는 영어 헤드라인에 최적화되어 있습니다. 한글 헤드라인은 기본적인 길이와 구조 분석만 제공됩니다.",
      },
    ],
    advantages: [
      "실시간 점수 및 등급 제공",
      "과학적 단어 밸런스 분석",
      "감정 분석으로 독자 반응 예측",
      "SEO 최적화 체크리스트",
      "구체적인 개선 제안",
      "100% 무료, 회원가입 불필요",
    ],
    useCases: [
      "블로그 포스트 제목 최적화",
      "이메일 마케팅 제목 테스트",
      "SNS 포스트 헤드라인 개선",
      "광고 카피 A/B 테스트 전 분석",
      "뉴스레터 제목 작성",
      "유튜브 썸네일 텍스트 검토",
    ],
  },

  "bg-remover": {
    whatIs:
      "Background Remover는 AI를 사용하여 이미지에서 배경을 자동으로 제거하는 도구입니다. U2-Net 딥러닝 모델을 기반으로 사람, 제품, 동물 등 전경 객체를 정확하게 감지하고 배경을 투명하게 만듭니다. WebGPU 가속을 지원하여 브라우저에서 빠르게 처리됩니다.",
    howToUse:
      "이미지를 드래그 앤 드롭하거나 파일을 선택하세요. 모델을 선택하고 (빠른 처리는 U2-Net-P, 고품질은 U2-Net) 'Remove Background' 버튼을 클릭합니다. 처리가 완료되면 결과 이미지와 마스크를 다운로드할 수 있습니다.",
    features: [
      "U2-Net 기반 AI 배경 제거",
      "WebGPU 가속으로 빠른 처리",
      "100% 클라이언트 사이드 - 이미지가 서버로 전송되지 않음",
      "임계값 조절로 세밀한 제어",
      "페더링으로 부드러운 엣지",
      "PNG, WebP 출력 지원",
    ],
    faq: [
      {
        q: "이미지가 서버로 전송되나요?",
        a: "아니요. 모든 처리는 브라우저 내에서 이루어지며, 이미지는 어디에도 업로드되지 않습니다. WebGPU 또는 WebAssembly를 사용하여 로컬에서 AI 모델이 실행됩니다.",
      },
      {
        q: "어떤 모델을 선택해야 하나요?",
        a: "빠른 처리가 필요하면 U2-Net-P(4MB)를, 높은 정확도가 필요하면 U2-Net(176MB)을 선택하세요. 대부분의 경우 U2-Net-P로 충분합니다.",
      },
      {
        q: "처리 시간은 얼마나 걸리나요?",
        a: "WebGPU를 지원하는 브라우저에서는 1-3초, WebAssembly 폴백에서는 5-15초 정도 소요됩니다. 이미지 크기와 하드웨어에 따라 달라질 수 있습니다.",
      },
      {
        q: "어떤 브라우저를 사용해야 하나요?",
        a: "WebGPU 가속을 위해 Chrome 113+, Edge 113+, Safari 17+ 사용을 권장합니다. 다른 브라우저에서는 WebAssembly 폴백이 작동합니다.",
      },
    ],
    whyNeeded:
      "온라인 쇼핑몰 상품 이미지, SNS 프로필 사진, 프레젠테이션 자료 등에서 깔끔한 배경 제거가 필요한 경우가 많습니다. 기존에는 Photoshop이나 유료 서비스가 필요했지만, 이 도구를 사용하면 무료로, 프라이버시를 지키면서 브라우저에서 바로 배경을 제거할 수 있습니다.",
    troubleshooting: [
      {
        problem: "배경 제거가 정확하지 않습니다",
        solution:
          "임계값(Threshold)을 조절해보세요. 낮추면 더 많은 영역이 유지되고, 높이면 더 많이 제거됩니다. 복잡한 이미지는 U2-Net 모델을 사용해보세요.",
      },
      {
        problem: "엣지가 거칠게 보입니다",
        solution:
          "Feather Radius 값을 높여 엣지를 부드럽게 만들 수 있습니다. 2-5px 정도가 자연스러운 결과를 제공합니다.",
      },
      {
        problem: "처리가 너무 느립니다",
        solution:
          "Chrome이나 Edge 최신 버전을 사용하면 WebGPU 가속을 활용할 수 있습니다. 또한 U2-Net-P 모델이 더 빠릅니다.",
      },
    ],
    advantages: [
      "AI 기반 정확한 배경 감지",
      "WebGPU로 GPU 가속 처리",
      "이미지가 서버로 전송되지 않아 100% 프라이버시 보장",
      "무료 사용, 회원가입 불필요",
      "다양한 모델 선택 가능",
      "투명 PNG 및 마스크 다운로드",
    ],
    useCases: [
      "쇼핑몰 상품 이미지 배경 제거",
      "SNS 프로필 사진 편집",
      "프레젠테이션 자료 제작",
      "로고 및 그래픽 소스 추출",
      "증명사진 배경 교체",
      "콜라주 및 합성 이미지 제작",
    ],
  },
  "og-generator": {
    whatIs:
      "OG Image Generator는 소셜 미디어 공유를 위한 Open Graph 이미지를 생성하는 도구입니다. Twitter, Facebook, LinkedIn 등에서 링크를 공유할 때 표시되는 미리보기 이미지를 쉽게 만들 수 있습니다. Satori 렌더링 엔진을 사용하여 React 컴포넌트를 SVG/PNG로 변환합니다.",
    howToUse:
      "제목과 설명을 입력하고, 템플릿을 선택한 후 스타일을 커스터마이징하세요. 실시간 프리뷰로 결과를 확인하고, 만족스러우면 PNG 또는 JPG로 다운로드합니다. 다양한 그라디언트 프리셋과 폰트 옵션을 사용할 수 있습니다.",
    features: [
      "6가지 프로페셔널 템플릿 (Basic, Gradient, Blog, Product, Social, Minimal)",
      "8가지 그라디언트 프리셋",
      "다양한 폰트 지원 (Inter, Roboto, Noto Sans 등)",
      "실시간 프리뷰",
      "PNG/JPG 다운로드",
      "한국어, 일본어 폰트 지원",
    ],
    faq: [
      {
        q: "OG 이미지란 무엇인가요?",
        a: "OG(Open Graph) 이미지는 Facebook, Twitter, LinkedIn 등에서 링크를 공유할 때 표시되는 미리보기 이미지입니다. 잘 디자인된 OG 이미지는 클릭률을 크게 높일 수 있습니다.",
      },
      {
        q: "권장 이미지 크기는 무엇인가요?",
        a: "표준 OG 이미지 크기는 1200×630px입니다. Twitter는 1200×600px, LinkedIn은 1200×627px을 권장합니다. 모든 사이즈를 지원합니다.",
      },
      {
        q: "한글이 깨지지 않나요?",
        a: "Noto Sans KR 폰트를 지원하여 한글이 정상적으로 렌더링됩니다. 일본어도 Noto Sans JP로 지원합니다.",
      },
      {
        q: "생성된 이미지는 어떻게 사용하나요?",
        a: "다운로드한 이미지를 웹 서버에 업로드하고, HTML의 og:image 메타 태그에 이미지 URL을 지정하면 됩니다.",
      },
    ],
    whyNeeded:
      "블로그 포스트, 제품 페이지, 이벤트 공유 시 눈에 띄는 미리보기 이미지가 있으면 클릭률이 크게 향상됩니다. 디자이너 없이도 전문적인 OG 이미지를 빠르게 만들 수 있어 마케팅 효과를 높일 수 있습니다.",
    troubleshooting: [
      {
        problem: "한글이 표시되지 않습니다",
        solution:
          "폰트 설정에서 'Noto Sans KR'을 선택하세요. 한글 폰트가 로드되면 정상적으로 표시됩니다.",
      },
      {
        problem: "프리뷰가 로딩되지 않습니다",
        solution:
          "폰트 로딩에 시간이 걸릴 수 있습니다. 잠시 기다려주세요. 문제가 지속되면 페이지를 새로고침하세요.",
      },
      {
        problem: "다운로드된 이미지 품질이 낮습니다",
        solution:
          "설정에서 출력 형식을 PNG로 선택하면 더 높은 품질의 이미지를 얻을 수 있습니다. JPG는 압축으로 인해 약간의 품질 저하가 있습니다.",
      },
    ],
    advantages: [
      "Satori 기반 고품질 렌더링",
      "실시간 프리뷰로 빠른 편집",
      "프로페셔널 템플릿 제공",
      "다국어 폰트 지원",
      "100% 클라이언트 사이드 처리",
      "무료 사용, 회원가입 불필요",
    ],
    useCases: [
      "블로그 포스트 썸네일 생성",
      "제품 페이지 OG 이미지",
      "이벤트 및 웨비나 홍보",
      "뉴스레터 링크 미리보기",
      "소셜 미디어 공유용 이미지",
      "포트폴리오 프로젝트 커버",
    ],
  },
  "image-converter": {
    whatIs:
      "Image Converter는 이미지를 다양한 포맷(JPEG, PNG, WebP, AVIF, GIF)으로 변환하는 도구입니다. 최신 이미지 포맷인 WebP와 AVIF를 지원하여 웹 성능을 최적화할 수 있습니다. 모든 처리는 브라우저에서 이루어져 개인정보가 보호됩니다.",
    howToUse:
      "이미지를 드래그 앤 드롭하거나 클릭하여 업로드합니다. 변환하고 싶은 출력 포맷을 선택하고, 품질을 조정한 후 변환 버튼을 클릭합니다. 변환된 이미지는 개별 또는 일괄 다운로드할 수 있습니다.",
    features: [
      "JPEG, PNG, WebP, AVIF, GIF 포맷 지원",
      "품질 조절로 파일 크기 최적화",
      "여러 이미지 일괄 변환",
      "브라우저별 포맷 지원 자동 감지",
      "100% 클라이언트 사이드 처리로 개인정보 보호",
    ],
    faq: [
      {
        q: "어떤 포맷을 사용해야 하나요?",
        a: "WebP는 품질과 파일 크기의 균형이 좋아 웹에 적합합니다. AVIF는 더 나은 압축을 제공하지만 브라우저 지원이 제한적입니다. JPEG는 사진에, PNG는 투명도가 필요한 그래픽에 적합합니다.",
      },
      {
        q: "AVIF가 제 브라우저에서 지원되나요?",
        a: "AVIF는 Chrome 85+, Firefox 93+, Safari 16+에서 지원됩니다. 도구가 자동으로 브라우저의 지원 포맷을 감지하여 표시합니다.",
      },
      {
        q: "변환 시 이미지 품질이 손실되나요?",
        a: "손실 포맷(JPEG, WebP, AVIF)은 품질 설정에 따라 일부 손실이 있습니다. PNG와 GIF는 무손실 포맷입니다. 품질 슬라이더로 파일 크기와 품질 사이의 균형을 조절할 수 있습니다.",
      },
      {
        q: "최대 파일 크기 제한이 있나요?",
        a: "엄격한 제한은 없지만, 매우 큰 이미지는 브라우저 메모리에 따라 처리 시간이 길어질 수 있습니다. 일반적으로 20MB 이하의 이미지가 원활하게 처리됩니다.",
      },
    ],
    whyNeeded:
      "웹 성능 최적화를 위해 WebP나 AVIF 같은 최신 포맷으로 변환하면 페이지 로딩 속도가 크게 향상됩니다. 다양한 플랫폼과 용도에 맞는 포맷으로 쉽게 변환할 수 있어 개발 워크플로우가 간소화됩니다.",
    troubleshooting: [
      {
        problem: "AVIF 옵션이 표시되지 않습니다",
        solution:
          "AVIF는 최신 브라우저에서만 지원됩니다. Chrome 85+, Firefox 93+, Safari 16+ 버전으로 업데이트하세요.",
      },
      {
        problem: "변환된 파일 크기가 오히려 커졌습니다",
        solution:
          "PNG에서 JPEG로 변환할 때 투명도 정보 때문에 크기가 커질 수 있습니다. 품질 설정을 낮추거나 WebP 포맷을 시도해보세요.",
      },
      {
        problem: "투명 배경이 검은색으로 변합니다",
        solution:
          "JPEG는 투명도를 지원하지 않습니다. 투명 배경이 필요하면 PNG나 WebP 포맷을 사용하세요.",
      },
    ],
    advantages: [
      "최신 WebP, AVIF 포맷 지원",
      "브라우저별 포맷 지원 자동 감지",
      "직관적인 품질 조절 슬라이더",
      "여러 이미지 일괄 처리",
      "100% 클라이언트 사이드 처리",
      "무료 사용, 회원가입 불필요",
    ],
    useCases: [
      "웹사이트 이미지 최적화",
      "블로그 포스트 이미지 변환",
      "소셜 미디어용 이미지 준비",
      "이메일 첨부용 이미지 압축",
      "다양한 플랫폼 호환성 확보",
      "포트폴리오 이미지 포맷 통일",
    ],
  },
  "sitemap-generator": {
    whatIs:
      "Sitemap Generator는 XML 사이트맵을 쉽게 생성하는 온라인 도구입니다. 사이트맵은 검색엔진이 웹사이트의 구조를 이해하고 모든 페이지를 효율적으로 크롤링하는 데 필수적인 파일입니다. URL 목록을 입력하면 표준 XML 형식의 sitemap.xml 파일을 자동으로 생성해줍니다.",
    howToUse:
      "URL 목록 입력 영역에 각 페이지의 URL을 한 줄에 하나씩 입력하세요. 변경 빈도와 우선순위를 설정한 후 생성 버튼을 클릭하면 XML 형식의 사이트맵이 생성됩니다. 결과물을 복사하여 sitemap.xml 파일로 저장하고 웹사이트 루트 디렉토리에 업로드하세요.",
    features: [
      "URL 목록으로 XML 사이트맵 생성",
      "변경 빈도(changefreq) 설정",
      "페이지별 우선순위(priority) 지정",
      "최종 수정일(lastmod) 자동 추가",
      "표준 XML 형식 출력",
      "대량 URL 일괄 처리",
    ],
    faq: [
      {
        q: "사이트맵이 왜 필요한가요?",
        a: "사이트맵은 검색엔진이 웹사이트의 모든 페이지를 발견하고 인덱싱하는 데 도움을 줍니다. 특히 새로운 사이트, 페이지가 많은 사이트, 동적 콘텐츠가 있는 사이트에 중요합니다.",
      },
      {
        q: "변경 빈도와 우선순위는 어떻게 설정하나요?",
        a: "변경 빈도는 페이지가 얼마나 자주 업데이트되는지를 나타냅니다. 우선순위(0.0~1.0)는 사이트 내 페이지의 상대적 중요도입니다. 홈페이지는 1.0, 중요 페이지는 0.8, 일반 페이지는 0.5 정도가 적당합니다.",
      },
      {
        q: "사이트맵 파일을 어디에 업로드해야 하나요?",
        a: "sitemap.xml 파일은 웹사이트의 루트 디렉토리(예: https://example.com/sitemap.xml)에 업로드하세요. 그런 다음 Google Search Console에서 사이트맵 URL을 제출하면 됩니다.",
      },
    ],
    whyNeeded:
      "사이트맵은 SEO의 기본 요소입니다. 검색엔진이 사이트의 모든 페이지를 쉽게 발견하고 크롤링할 수 있게 해주며, 새 페이지가 빠르게 인덱싱되도록 도와줍니다. 특히 대규모 사이트나 복잡한 구조의 사이트에서 필수적입니다.",
    troubleshooting: [
      {
        problem: "생성된 사이트맵이 유효하지 않다고 나옵니다",
        solution:
          "URL이 올바른 형식(https://로 시작)인지 확인하세요. 특수문자가 포함된 URL은 인코딩이 필요할 수 있습니다.",
      },
      {
        problem: "사이트맵을 업로드했는데 Google에서 인식하지 못합니다",
        solution:
          "robots.txt 파일에 'Sitemap: https://yoursite.com/sitemap.xml' 줄을 추가하고, Google Search Console에서 직접 사이트맵 URL을 제출하세요.",
      },
    ],
    advantages: [
      "복잡한 XML 구문 자동 생성",
      "표준 sitemap 프로토콜 준수",
      "직관적인 사용자 인터페이스",
      "설치 없이 브라우저에서 즉시 사용",
      "무료 사용, 회원가입 불필요",
    ],
    useCases: [
      "새 웹사이트 SEO 설정",
      "사이트 구조 변경 시 업데이트",
      "검색엔진 크롤링 효율화",
      "새 페이지 빠른 인덱싱",
      "대규모 사이트 관리",
    ],
  },
  "meta-tag-analyzer": {
    whatIs:
      "Meta Tag Analyzer는 웹페이지의 메타 태그를 분석하고 SEO 점수를 제공하는 온라인 도구입니다. 제목, 설명, Open Graph, Twitter Card 등 모든 메타 태그를 검사하고 개선점을 제안합니다.",
    howToUse:
      "분석하려는 웹페이지의 URL을 입력하고 분석 버튼을 클릭하세요. 도구가 페이지의 모든 메타 태그를 수집하여 SEO 점수와 함께 상세한 분석 결과를 표시합니다.",
    features: [
      "메타 태그 자동 수집 및 분석",
      "SEO 점수 산출",
      "Open Graph 태그 검사",
      "Twitter Card 검사",
      "개선 제안 제공",
      "경쟁사 비교 분석",
    ],
    faq: [
      {
        q: "SEO 점수는 어떻게 계산되나요?",
        a: "제목 길이, 설명 길이, 키워드 포함 여부, Open Graph 완성도, Twitter Card 설정 등 다양한 요소를 종합하여 점수를 산출합니다.",
      },
      {
        q: "100점을 받으면 검색 순위가 올라가나요?",
        a: "메타 태그는 SEO의 일부일 뿐입니다. 100점은 기술적으로 최적화되었다는 의미이며, 실제 검색 순위는 콘텐츠 품질, 백링크 등 다른 요소에도 영향을 받습니다.",
      },
    ],
    whyNeeded:
      "메타 태그는 검색엔진이 페이지 내용을 이해하고 검색 결과에 표시하는 방식에 직접적인 영향을 미칩니다. 잘 최적화된 메타 태그는 클릭률을 높이고 소셜 미디어 공유 시 적절한 미리보기를 제공합니다.",
    troubleshooting: [
      {
        problem: "분석 결과에 일부 태그가 표시되지 않습니다",
        solution:
          "일부 사이트는 JavaScript로 메타 태그를 동적으로 생성합니다. 이 경우 브라우저 개발자 도구에서 직접 확인하세요.",
      },
      {
        problem: "Open Graph 이미지가 잘못 표시됩니다",
        solution:
          "og:image URL이 절대 경로인지, 이미지 크기가 권장 크기(1200x630px)인지 확인하세요.",
      },
    ],
    advantages: [
      "한눈에 보는 SEO 점수",
      "구체적인 개선 제안",
      "소셜 미디어 미리보기 확인",
      "경쟁사 분석 가능",
      "무료 사용",
    ],
    useCases: [
      "웹사이트 SEO 감사",
      "경쟁사 메타 태그 분석",
      "소셜 미디어 공유 최적화",
      "새 페이지 출시 전 점검",
      "SEO 교육 및 학습",
    ],
  },
  "robots-generator": {
    whatIs:
      "Robots.txt Generator는 검색엔진 크롤러를 위한 robots.txt 파일을 쉽게 생성하는 온라인 도구입니다. 크롤링을 허용하거나 차단할 경로를 지정하고 사이트맵 위치를 명시할 수 있습니다.",
    howToUse:
      "User-agent를 선택하고(모든 봇 또는 특정 봇), Allow/Disallow 규칙을 추가하세요. 사이트맵 URL을 입력하고 생성 버튼을 클릭하면 robots.txt 내용이 생성됩니다.",
    features: [
      "User-agent별 규칙 설정",
      "Allow/Disallow 경로 지정",
      "사이트맵 URL 추가",
      "Crawl-delay 설정",
      "일반적인 템플릿 제공",
      "실시간 미리보기",
    ],
    faq: [
      {
        q: "robots.txt가 왜 필요한가요?",
        a: "robots.txt는 검색엔진에 크롤링해도 되는 페이지와 안 되는 페이지를 알려줍니다. 관리자 페이지나 중복 콘텐츠를 차단하여 크롤링 효율성을 높이고 서버 부하를 줄일 수 있습니다.",
      },
      {
        q: "Disallow로 페이지를 숨길 수 있나요?",
        a: "robots.txt는 크롤링만 차단할 뿐, 보안 조치가 아닙니다. 민감한 페이지는 인증이나 noindex 메타 태그를 사용해야 합니다.",
      },
    ],
    whyNeeded:
      "robots.txt는 검색엔진 최적화의 기본입니다. 불필요한 페이지의 크롤링을 방지하여 중요한 페이지가 더 잘 인덱싱되도록 하고, 서버 리소스를 효율적으로 사용할 수 있게 합니다.",
    troubleshooting: [
      {
        problem: "페이지가 여전히 검색 결과에 나타납니다",
        solution:
          "robots.txt는 크롤링만 차단합니다. 이미 인덱싱된 페이지를 제거하려면 Google Search Console에서 삭제 요청하거나 noindex 태그를 사용하세요.",
      },
      {
        problem: "사이트 전체가 검색되지 않습니다",
        solution:
          "robots.txt에서 실수로 모든 경로를 Disallow했을 수 있습니다. 'Disallow: /'가 있는지 확인하세요.",
      },
    ],
    advantages: [
      "직관적인 규칙 생성",
      "일반적인 패턴 템플릿 제공",
      "문법 오류 방지",
      "실시간 미리보기",
      "무료 사용",
    ],
    useCases: [
      "새 사이트 SEO 설정",
      "관리자 페이지 크롤링 차단",
      "중복 콘텐츠 차단",
      "API 엔드포인트 보호",
      "크롤링 빈도 조절",
    ],
  },
  "serp-preview": {
    whatIs:
      "SERP Preview는 Google 검색 결과에서 웹페이지가 어떻게 표시되는지 미리 보여주는 도구입니다. 제목과 설명의 길이를 최적화하고 클릭률을 높이는 데 도움을 줍니다.",
    howToUse:
      "페이지 URL, 제목(title), 설명(meta description)을 입력하면 실제 Google 검색 결과와 동일한 형식으로 미리보기가 표시됩니다. 데스크톱과 모바일 버전을 각각 확인할 수 있습니다.",
    features: [
      "Google 검색 결과 미리보기",
      "데스크톱/모바일 뷰 전환",
      "제목 길이 최적화 안내",
      "설명 길이 최적화 안내",
      "잘림 표시 확인",
      "픽셀 기반 정확한 측정",
    ],
    faq: [
      {
        q: "제목의 권장 길이는 얼마인가요?",
        a: "데스크톱에서는 약 580픽셀(약 55-60자), 모바일에서는 약 65-70자입니다. 이 도구는 픽셀 기반으로 정확하게 측정합니다.",
      },
      {
        q: "설명의 권장 길이는 얼마인가요?",
        a: "데스크톱에서는 약 920픽셀(약 155-160자), 모바일에서는 약 120자입니다. 중요한 내용은 앞부분에 배치하세요.",
      },
    ],
    whyNeeded:
      "검색 결과에서 제목과 설명이 어떻게 표시되는지 미리 확인하면 클릭률(CTR)을 높일 수 있습니다. 잘리는 부분을 확인하고 핵심 메시지가 보이도록 최적화할 수 있습니다.",
    troubleshooting: [
      {
        problem: "실제 검색 결과와 다르게 표시됩니다",
        solution:
          "Google은 검색어에 따라 제목과 설명을 동적으로 변경할 수 있습니다. 이 도구는 기본적인 표시 방식을 보여줍니다.",
      },
      {
        problem: "제목이 너무 길게 잘립니다",
        solution:
          "픽셀 기반으로 측정되므로 영문과 한글의 길이가 다릅니다. 한글은 글자 수가 적어도 픽셀이 클 수 있습니다.",
      },
    ],
    advantages: [
      "실제 Google 검색 결과 형식",
      "픽셀 기반 정확한 측정",
      "데스크톱/모바일 모두 지원",
      "실시간 미리보기",
      "무료 사용",
    ],
    useCases: [
      "새 페이지 메타 태그 작성",
      "기존 페이지 CTR 개선",
      "A/B 테스트용 제목 비교",
      "SEO 교육 및 학습",
      "클라이언트 프레젠테이션",
    ],
  },
  "share-as-image": {
    whatIs:
      "Share as Image는 코드 스니펫을 아름다운 이미지로 변환하는 도구입니다. Carbon(carbon.now.sh)과 유사하게 코드를 소셜 미디어, 문서, 프레젠테이션에 공유하기 좋은 시각적으로 매력적인 그래픽으로 만들어줍니다.",
    howToUse:
      "코드를 입력하고, 테마와 배경을 선택한 다음, 스타일 옵션(폰트 크기, 패딩, 테두리 등)을 조정합니다. 완성된 이미지를 PNG, JPEG 또는 SVG로 다운로드하거나 클립보드에 직접 복사할 수 있습니다.",
    features: [
      "8가지 인기 코드 테마 (Dracula, Monokai, Night Owl 등)",
      "그라디언트 포함 9가지 배경 옵션",
      "자동 언어 감지",
      "맞춤 폰트 크기, 패딩, 테두리 반경",
      "macOS 스타일 윈도우 컨트롤",
      "PNG, JPEG, SVG 내보내기",
      "클립보드에 이미지 복사",
    ],
    faq: [
      {
        q: "Share as Image란 무엇인가요?",
        a: "코드 스니펫을 아름다운 이미지로 변환하는 도구입니다. 소셜 미디어, 블로그, 프레젠테이션 등에서 코드를 시각적으로 공유할 때 유용합니다.",
      },
      {
        q: "어떤 내보내기 형식이 지원되나요?",
        a: "PNG(최고 품질), JPEG(작은 파일 크기), SVG(확장 가능한 벡터)를 지원합니다. 대부분의 용도에는 PNG를 권장합니다.",
      },
    ],
    whyNeeded:
      "코드를 공유할 때 단순 텍스트보다 이미지가 더 눈에 띄고 가독성이 좋습니다. 트위터, LinkedIn, 블로그 등에서 코드를 공유하거나 발표 자료를 만들 때 유용합니다.",
    troubleshooting: [
      {
        problem: "이미지가 흐릿하게 보입니다",
        solution:
          "Export Scale을 2x 이상으로 설정하세요. 고해상도 디스플레이에서 더 선명하게 표시됩니다.",
      },
      {
        problem: "클립보드 복사가 안 됩니다",
        solution:
          "일부 브라우저에서는 클립보드 API 권한이 필요합니다. 대신 다운로드 기능을 사용하세요.",
      },
    ],
    advantages: [
      "Carbon과 유사한 아름다운 코드 이미지",
      "다양한 테마와 배경 옵션",
      "100% 브라우저 내 처리",
      "무료 사용",
      "클립보드 복사 지원",
    ],
    useCases: [
      "소셜 미디어 코드 공유",
      "블로그 포스트 이미지",
      "프레젠테이션 슬라이드",
      "기술 문서 스크린샷",
      "코드 리뷰 자료",
    ],
  },

  "token-counter": {
    whatIs:
      "토큰 카운터는 GPT-4, Claude 등 AI 모델에서 텍스트가 몇 개의 토큰으로 분할되는지 계산하는 도구입니다. 토큰은 AI가 텍스트를 처리하는 기본 단위로, 영어의 경우 보통 단어의 3/4, 한국어의 경우 단어당 2-3개의 토큰으로 분할됩니다. API 비용과 컨텍스트 윈도우 사용량을 미리 파악할 수 있습니다.",
    howToUse:
      "사용할 AI 모델(GPT-4o, Claude 3.5 Sonnet 등)을 선택합니다. 텍스트를 입력하면 실시간으로 토큰 수, 문자 수, 단어 수가 표시됩니다. 예상 출력 비율을 조절하여 총 API 비용을 예측할 수 있습니다. 컨텍스트 윈도우 사용률도 함께 확인하세요.",
    features: [
      "GPT-4o, GPT-4o-mini, GPT-3.5-turbo, o1 등 OpenAI 모델 지원",
      "Claude 3.5 Sonnet, Claude 3 Opus, Claude 3 Haiku 등 Anthropic 모델 지원",
      "실시간 토큰 카운트 (gpt-tokenizer 사용)",
      "API 비용 계산 (입력/출력 토큰 기준)",
      "컨텍스트 윈도우 사용률 시각화",
      "출력 토큰 비율 조절 가능",
      "100% 브라우저 내 처리",
    ],
    faq: [
      {
        q: "토큰이란 무엇인가요?",
        a: "토큰은 AI 모델이 텍스트를 처리하는 기본 단위입니다. 영어에서 하나의 토큰은 보통 4자 정도이며, 한 단어가 1~3개의 토큰이 됩니다. 한국어는 더 많은 토큰을 사용하는 경향이 있습니다.",
      },
      {
        q: "OpenAI와 Claude의 토큰 계산이 다른가요?",
        a: "네, 각 회사마다 다른 토크나이저를 사용합니다. 하지만 Claude는 GPT-4와 유사한 토크나이저를 사용하므로 대략 비슷한 결과가 나옵니다. 이 도구는 정확도를 위해 모델별로 약간의 보정을 적용합니다.",
      },
      {
        q: "비용 계산은 얼마나 정확한가요?",
        a: "입력 토큰 비용은 정확하게 계산됩니다. 출력 토큰은 예상 비율에 따라 계산되므로 실제 사용량과 다를 수 있습니다. 출력 비율을 조절하여 다양한 시나리오를 시뮬레이션해보세요.",
      },
      {
        q: "컨텍스트 윈도우란 무엇인가요?",
        a: "AI 모델이 한 번에 처리할 수 있는 최대 토큰 수입니다. GPT-4o는 128K, Claude 3.5 Sonnet은 200K 토큰을 지원합니다. 이 한도를 초과하면 텍스트를 분할해야 합니다.",
      },
    ],
    whyNeeded:
      "AI API 비용을 예측하고 최적화하려면 토큰 수를 알아야 합니다. 특히 대량의 텍스트를 처리하거나 프로덕션 환경에서 비용 관리가 중요할 때 필수적입니다. 컨텍스트 윈도우 초과를 미리 방지하여 에러를 예방할 수도 있습니다.",
    troubleshooting: [
      {
        problem: "토큰 수가 예상보다 많습니다",
        solution:
          "한국어, 일본어 등 비영어권 텍스트는 더 많은 토큰을 사용합니다. 불필요한 공백, 줄바꿈을 제거하고 텍스트를 압축해보세요.",
      },
      {
        problem: "컨텍스트 윈도우를 초과했습니다",
        solution:
          "텍스트를 청크로 분할하거나, 더 큰 컨텍스트 윈도우를 지원하는 모델(Claude 3.5 Sonnet 200K, GPT-4o 128K)을 선택하세요.",
      },
      {
        problem: "비용이 너무 높게 나옵니다",
        solution:
          "gpt-4o-mini나 claude-3-haiku 같은 저렴한 모델을 고려해보세요. 입력 프롬프트를 최적화하여 토큰 수를 줄이는 것도 효과적입니다.",
      },
    ],
    advantages: [
      "14개 이상의 AI 모델 지원 (OpenAI + Anthropic)",
      "실시간 토큰 카운트",
      "정확한 비용 예측",
      "컨텍스트 윈도우 시각화",
      "100% 무료 - 회원가입 불필요",
      "브라우저 내 처리로 텍스트 프라이버시 보장",
    ],
    useCases: [
      "API 비용 예측 및 최적화",
      "프롬프트 엔지니어링 시 토큰 관리",
      "컨텍스트 윈도우 초과 방지",
      "대량 텍스트 처리 비용 산정",
      "AI 프로젝트 예산 계획",
      "모델 간 비용 비교",
    ],
  },
} as const satisfies Readonly<Record<ToolSlug, ToolSeoContent>>;
