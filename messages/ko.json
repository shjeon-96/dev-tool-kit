{
  "site": {
    "title": "Web Toolkit",
    "description": "개발자를 위한 웹 기반 올인원 도구 모음. JSON Formatter, JWT Decoder, Image Resizer 등을 설치 없이 브라우저에서 바로 사용하세요.",
    "keywords": "개발자 도구, JSON 변환, JWT 디코딩, 이미지 리사이즈, 웹툴"
  },
  "navigation": {
    "home": "홈",
    "tools": "도구",
    "skipToContent": "본문으로 건너뛰기"
  },
  "sidebar": {
    "allTools": "모든 도구",
    "categories": {
      "text": "텍스트",
      "media": "미디어",
      "converters": "변환",
      "security": "보안"
    }
  },
  "footer": {
    "copyright": "© 2025 Web Toolkit. All rights reserved.",
    "privacy": "개인정보처리방침",
    "github": "GitHub"
  },
  "common": {
    "copy": "복사",
    "copied": "복사됨!",
    "clear": "지우기",
    "download": "다운로드",
    "upload": "업로드",
    "generate": "생성",
    "format": "포맷",
    "minify": "압축",
    "encode": "인코딩",
    "decode": "디코딩",
    "convert": "변환",
    "reset": "초기화",
    "input": "입력",
    "output": "출력",
    "result": "결과",
    "error": "오류",
    "success": "성공",
    "loading": "로딩 중...",
    "noData": "데이터 없음",
    "searchTools": "도구 검색...",
    "searchPlaceholder": "도구 이름을 입력하세요...",
    "noResults": "결과가 없습니다.",
    "tools": "도구"
  },
  "tools": {
    "json-formatter": {
      "title": "JSON Formatter",
      "description": "JSON 데이터를 포맷팅, 압축, 검증합니다."
    },
    "jwt-decoder": {
      "title": "JWT Decoder",
      "description": "JWT 토큰을 디코딩하여 Header, Payload, 만료 시간을 확인합니다."
    },
    "image-resizer": {
      "title": "Image Resizer",
      "description": "이미지 크기 조절, 포맷 변환, 품질 조정을 브라우저에서 처리합니다."
    },
    "unix-timestamp": {
      "title": "Unix Timestamp",
      "description": "Unix 타임스탬프와 날짜/시간 간 양방향 변환을 지원합니다."
    },
    "base64-converter": {
      "title": "Base64 Converter",
      "description": "텍스트, 파일을 Base64로 인코딩/디코딩합니다."
    },
    "app-icon-generator": {
      "title": "App Icon Generator",
      "description": "iOS, Android, Favicon 규격에 맞는 앱 아이콘을 일괄 생성합니다."
    },
    "qr-generator": {
      "title": "QR Code Generator",
      "description": "URL, WiFi, 연락처 등 다양한 형식의 QR 코드를 생성합니다."
    },
    "color-picker": {
      "title": "Color Picker",
      "description": "이미지에서 색상을 추출하고 팔레트를 생성합니다."
    },
    "url-parser": {
      "title": "URL Parser",
      "description": "URL을 분석하여 구성 요소를 분해하고 쿼리 파라미터를 편집합니다."
    },
    "uuid-generator": {
      "title": "UUID/ULID Generator",
      "description": "UUID v1, v4 및 ULID를 생성하고 다양한 포맷으로 변환합니다."
    },
    "base-converter": {
      "title": "Number Base Converter",
      "description": "2진수, 8진수, 10진수, 16진수 간 상호 변환을 지원합니다."
    },
    "hash-generator": {
      "title": "Hash Generator",
      "description": "MD5, SHA-1, SHA-256, SHA-512 해시를 생성하고 비교합니다."
    },
    "sql-formatter": {
      "title": "SQL Formatter",
      "description": "SQL 쿼리를 포맷팅하고 다양한 방언을 지원합니다."
    },
    "cron-parser": {
      "title": "Cron Parser",
      "description": "Cron 표현식을 해석하고 다음 실행 시간을 예측합니다."
    },
    "markdown-preview": {
      "title": "Markdown Preview",
      "description": "Markdown을 실시간으로 렌더링하고 코드 하이라이팅을 지원합니다."
    },
    "diff-checker": {
      "title": "Diff Checker",
      "description": "두 텍스트의 차이점을 비교하고 변경 사항을 시각화합니다."
    },
    "lorem-generator": {
      "title": "Lorem Ipsum Generator",
      "description": "더미 텍스트를 단어, 문장, 문단 단위로 생성합니다."
    },
    "url-encoder": {
      "title": "URL Encoder/Decoder",
      "description": "URL을 인코딩하거나 디코딩합니다."
    },
    "html-entity": {
      "title": "HTML Entity Encoder",
      "description": "HTML 특수문자를 엔티티로 인코딩/디코딩합니다."
    },
    "box-shadow": {
      "title": "Box Shadow Generator",
      "description": "CSS box-shadow를 시각적으로 편집하고 코드를 생성합니다."
    },
    "gradient-generator": {
      "title": "Gradient Generator",
      "description": "CSS 그라디언트를 시각적으로 편집하고 코드를 생성합니다."
    },
    "ua-parser": {
      "title": "User Agent Parser",
      "description": "User Agent 문자열을 분석하여 브라우저, OS, 디바이스 정보를 확인합니다."
    },
    "regex-tester": {
      "title": "Regex Tester",
      "description": "정규식을 테스트하고 매칭 결과를 실시간으로 확인합니다."
    },
    "meta-generator": {
      "title": "Meta Tag Generator",
      "description": "SEO용 메타 태그, Open Graph, Twitter Card를 생성합니다."
    },
    "curl-builder": {
      "title": "cURL Builder",
      "description": "HTTP 요청을 구성하고 cURL 명령어를 생성합니다."
    },
    "svg-optimizer": {
      "title": "SVG Optimizer",
      "description": "SVG 파일을 최적화하여 파일 크기를 줄입니다."
    },
    "css-to-tailwind": {
      "title": "CSS to Tailwind",
      "description": "CSS 속성을 Tailwind CSS 클래스로 변환합니다."
    },
    "prettier-playground": {
      "title": "Prettier Playground",
      "description": "다양한 언어의 코드를 Prettier로 포맷팅합니다."
    }
  },
  "seo": {
    "breadcrumb": {
      "home": "홈",
      "tools": "도구"
    },
    "sections": {
      "whatIs": "이 도구는 무엇인가요?",
      "howToUse": "사용 방법",
      "features": "특징",
      "faq": "자주 묻는 질문"
    },
    "json-formatter": {
      "whatIs": "JSON Formatter는 JSON 데이터를 자동으로 정리하고 들여쓰기하여 읽기 쉽게 만들어주는 온라인 도구입니다. 복잡하게 압축된 JSON도 한 번의 클릭으로 깔끔하게 포맷팅할 수 있습니다.",
      "howToUse": "왼쪽 입력창에 JSON 데이터를 붙여넣으면 자동으로 오른쪽에 포맷팅된 결과가 표시됩니다. 들여쓰기 크기를 2, 4, 탭 중에서 선택할 수 있으며, 압축 버튼을 클릭하면 공백 없이 최소화된 JSON을 얻을 수 있습니다.",
      "features": [
        "브라우저에서 모든 처리 완료 - 데이터가 서버로 전송되지 않아 안전합니다",
        "실시간 문법 검증으로 오류 위치를 즉시 확인",
        "다크 모드 지원",
        "복사 버튼으로 결과를 클립보드에 바로 저장"
      ],
      "faq": [
        {
          "q": "입력한 JSON이 서버에 저장되나요?",
          "a": "아니요. 모든 처리는 브라우저 내에서 이루어지며, 입력 데이터는 어디에도 전송되거나 저장되지 않습니다."
        },
        {
          "q": "대용량 JSON도 처리할 수 있나요?",
          "a": "네, 브라우저 메모리가 허용하는 범위 내에서 수 MB 크기까지 문제없이 작동합니다."
        }
      ]
    },
    "jwt-decoder": {
      "whatIs": "JWT Decoder는 JSON Web Token을 안전하게 디코딩하여 헤더, 페이로드, 서명 구성 요소를 확인할 수 있는 도구입니다. 토큰 만료 시간과 클레임을 즉시 확인할 수 있습니다.",
      "howToUse": "입력 필드에 JWT 토큰을 붙여넣으면 디코딩된 헤더와 페이로드가 즉시 표시됩니다. 만료 상태와 토큰 구조를 한눈에 확인할 수 있습니다.",
      "features": [
        "서버 통신 없이 즉시 디코딩",
        "만료 상태 시각적 표시",
        "모든 JWT 알고리즘 지원 (HS256, RS256 등)",
        "읽기 쉬운 JSON 형식 출력"
      ],
      "faq": [
        {
          "q": "여기서 JWT를 디코딩하는 것이 안전한가요?",
          "a": "네. 모든 디코딩은 브라우저에서 이루어지며, 토큰은 기기를 떠나지 않습니다."
        },
        {
          "q": "JWT 서명을 검증할 수 있나요?",
          "a": "이 도구는 검사용 디코딩을 수행합니다. 서명 검증에는 시크릿 또는 공개 키가 필요합니다."
        }
      ]
    },
    "image-resizer": {
      "whatIs": "Image Resizer는 서버에 업로드하지 않고 브라우저에서 직접 이미지 크기 조절, 포맷 변환, 품질 조정을 할 수 있는 도구입니다. 빠르고 안전하며 오프라인에서도 작동합니다.",
      "howToUse": "이미지를 업로드하거나 드래그 앤 드롭하세요. 원하는 크기나 비율을 설정하고, 출력 포맷(PNG, JPEG, WebP)과 품질을 선택한 후 결과를 다운로드하세요.",
      "features": [
        "브라우저에서 완전히 처리 - 업로드 불필요",
        "PNG, JPEG, WebP, GIF 포맷 지원",
        "종횡비 유지 또는 사용자 정의 크기",
        "여러 이미지 일괄 리사이즈"
      ],
      "faq": [
        {
          "q": "이미지가 서버에 업로드되나요?",
          "a": "아니요. 모든 처리는 브라우저에서 로컬로 이루어집니다. 이미지는 기기에 남아 있습니다."
        },
        {
          "q": "처리할 수 있는 최대 파일 크기는 얼마인가요?",
          "a": "엄격한 제한은 없지만, 매우 큰 파일은 기기 메모리에 따라 느려질 수 있습니다."
        }
      ]
    },
    "hash-generator": {
      "whatIs": "Hash Generator는 MD5, SHA-1, SHA-256, SHA-512 알고리즘을 사용하여 암호화 해시를 생성합니다. 파일 무결성 검증과 패스워드 해싱에 적합합니다.",
      "howToUse": "해시할 텍스트를 입력하거나 파일을 업로드하세요. 필요한 알고리즘을 선택하고 생성된 해시 값을 복사하거나 예상 해시와 비교하세요.",
      "features": [
        "하나의 도구에서 여러 해시 알고리즘 제공",
        "무결성 검증을 위한 파일 해싱",
        "검증을 위한 해시 비교",
        "보안을 위한 클라이언트 사이드 처리"
      ],
      "faq": [
        {
          "q": "어떤 해시 알고리즘을 사용해야 하나요?",
          "a": "대부분의 용도에 SHA-256을 권장합니다. MD5와 SHA-1은 더 빠르지만 보안성이 낮습니다."
        },
        {
          "q": "큰 파일도 해시할 수 있나요?",
          "a": "네, 파일은 청크 단위로 처리되어 큰 크기도 효율적으로 처리합니다."
        }
      ]
    },
    "uuid-generator": {
      "whatIs": "UUID/ULID Generator는 다양한 형식의 고유 식별자를 생성합니다. UUID v1(시간 기반), UUID v4(랜덤), ULID(정렬 가능)를 즉시 생성할 수 있습니다.",
      "howToUse": "필요한 ID 유형을 선택하고 생성 버튼을 클릭하세요. 클립보드에 복사하거나 대량으로 여러 ID를 한 번에 생성할 수 있습니다.",
      "features": [
        "UUID v1, v4, ULID 지원",
        "여러 ID 대량 생성",
        "다양한 형식 옵션 (표준, 압축, 대문자)",
        "클립보드에 즉시 복사"
      ],
      "faq": [
        {
          "q": "UUID와 ULID의 차이점은 무엇인가요?",
          "a": "UUID는 표준 고유 식별자입니다. ULID는 생성 시간순으로 정렬 가능하고 URL에 더 친화적입니다."
        },
        {
          "q": "생성된 ID가 정말 고유한가요?",
          "a": "네. UUID v4는 암호학적으로 안전한 무작위 생성을 사용하며 충돌 확률이 거의 0에 가깝습니다."
        }
      ]
    },
    "qr-generator": {
      "whatIs": "QR Code Generator는 URL, WiFi 자격 증명, 연락처 카드, 일반 텍스트용 스캔 가능한 QR 코드를 생성합니다. 필요에 따라 색상과 크기를 사용자 정의할 수 있습니다.",
      "howToUse": "QR 코드 유형을 선택하고 데이터를 입력하면 즉시 미리보기가 표시됩니다. 전경색과 배경색을 사용자 정의한 후 PNG 또는 SVG 형식으로 다운로드하세요.",
      "features": [
        "다양한 QR 유형: URL, WiFi, vCard, 텍스트",
        "사용자 정의 색상 및 크기 옵션",
        "PNG 및 SVG 다운로드 형식",
        "안정성을 위한 오류 수정 레벨"
      ],
      "faq": [
        {
          "q": "QR 코드 크기는 얼마로 해야 하나요?",
          "a": "인쇄용으로는 최소 2cm x 2cm. 디지털 디스플레이에는 보통 200x200 픽셀이면 충분합니다."
        },
        {
          "q": "QR 코드에 로고를 추가할 수 있나요?",
          "a": "오류 수정으로 부분 가림이 가능하지만, 안정적인 스캔을 위해 중앙은 비워두는 것이 좋습니다."
        }
      ]
    },
    "color-picker": {
      "whatIs": "Color Picker는 이미지에서 색상을 추출하고 색상 형식 간 변환을 합니다. 디자인 프로젝트를 위한 조화로운 색상 팔레트를 만들 수 있습니다.",
      "howToUse": "이미지를 업로드하여 색상을 추출하거나 색상 값을 직접 입력하세요. HEX, RGB, HSL 형식 간 변환하고 프로젝트에 사용할 값을 복사하세요.",
      "features": [
        "모든 이미지에서 색상 추출",
        "HEX, RGB, HSL, HSV 간 변환",
        "보색 팔레트 생성",
        "즐겨찾기 색상 저장"
      ],
      "faq": [
        {
          "q": "한 이미지에서 여러 색상을 추출할 수 있나요?",
          "a": "네. 이미지 어디든 클릭하여 색상을 선택하고 추출된 팔레트를 확인하세요."
        },
        {
          "q": "어떤 색상 형식이 지원되나요?",
          "a": "HEX, RGB, HSL, HSV 형식이 완전히 지원되며 즉시 변환됩니다."
        }
      ]
    },
    "base64-converter": {
      "whatIs": "Base64 Converter는 텍스트와 파일을 Base64 형식으로 인코딩/디코딩합니다. HTML, CSS에 데이터를 임베딩하거나 바이너리 데이터를 텍스트로 전송하는 데 필수적입니다.",
      "howToUse": "텍스트를 입력하거나 파일을 업로드하세요. 인코딩을 클릭하여 Base64로 변환하거나, Base64 텍스트를 붙여넣고 디코딩하여 원본을 확인하세요.",
      "features": [
        "텍스트 및 파일 인코딩/디코딩",
        "이미지용 Data URL 생성",
        "대용량 파일 효율적 처리",
        "결과 복사 또는 다운로드"
      ],
      "faq": [
        {
          "q": "Base64는 무엇에 사용되나요?",
          "a": "Base64는 바이너리 데이터를 ASCII 텍스트로 변환하며, HTML/CSS에 이미지를 임베딩하거나 JSON으로 데이터 전송에 유용합니다."
        },
        {
          "q": "Base64가 데이터를 암호화하나요?",
          "a": "아니요. Base64는 인코딩 방식이지 암호화가 아닙니다. 누구나 쉽게 디코딩할 수 있습니다."
        }
      ]
    },
    "base-converter": {
      "whatIs": "Number Base Converter는 2진수, 8진수, 10진수, 16진수 간 숫자를 즉시 변환합니다. 프로그래머와 컴퓨터 과학 학생에게 필수적인 도구입니다.",
      "howToUse": "지원되는 진법(2진수, 8진수, 10진수, 16진수)으로 숫자를 입력하세요. 다른 모든 진법으로의 변환 결과를 즉시 확인할 수 있습니다.",
      "features": [
        "2진수, 8진수, 10진수, 16진수 변환",
        "실시간 양방향 변환",
        "큰 숫자 지원",
        "각 형식별 원클릭 복사"
      ],
      "faq": [
        {
          "q": "어떤 진법이 지원되나요?",
          "a": "2진수(base 2), 8진수(base 8), 10진수(base 10), 16진수(base 16)가 완전히 지원됩니다."
        },
        {
          "q": "매우 큰 숫자도 변환할 수 있나요?",
          "a": "네, 변환기는 JavaScript의 안전한 정수 한계까지 처리하며 정확한 결과를 제공합니다."
        }
      ]
    },
    "sql-formatter": {
      "whatIs": "SQL Formatter는 가독성 향상을 위해 SQL 쿼리를 정리하고 포맷팅합니다. MySQL, PostgreSQL, SQLite 등 다양한 SQL 방언을 지원합니다.",
      "howToUse": "입력 영역에 SQL 쿼리를 붙여넣으세요. 정확한 포맷팅을 위해 SQL 방언을 선택하세요. 포맷팅된 결과를 복사하거나 파일로 다운로드하세요.",
      "features": [
        "다양한 SQL 방언 지원",
        "사용자 정의 들여쓰기 및 스타일",
        "가독성을 위한 구문 강조",
        "주석 유지 또는 제거"
      ],
      "faq": [
        {
          "q": "어떤 SQL 방언이 지원되나요?",
          "a": "MySQL, PostgreSQL, SQLite, SQL Server, 표준 SQL이 완전히 지원됩니다."
        },
        {
          "q": "포맷팅이 쿼리 동작을 변경하나요?",
          "a": "아니요. 포맷팅은 공백과 들여쓰기만 영향을 주며 쿼리 로직은 변경되지 않습니다."
        }
      ]
    },
    "cron-parser": {
      "whatIs": "Cron Parser는 cron 표현식을 해석하고 다음 실행 시간을 보여줍니다. 예약된 작업 구성을 쉽게 이해하고 검증할 수 있습니다.",
      "howToUse": "cron 표현식을 입력하면 사람이 읽을 수 있는 설명이 표시됩니다. 다음 실행 시간을 확인하고 스케줄이 올바른지 검증하세요.",
      "features": [
        "사람이 읽을 수 있는 cron 설명",
        "다음 10회 실행 시간 미리보기",
        "일반적인 cron 예제 라이브러리",
        "오류 메시지와 함께 검증"
      ],
      "faq": [
        {
          "q": "cron 파서가 어떤 형식을 받나요?",
          "a": "표준 5필드 cron 형식(분, 시, 일, 월, 요일)과 초가 포함된 6필드를 지원합니다."
        },
        {
          "q": "스케줄에서 cron 표현식을 생성할 수 있나요?",
          "a": "네, 시각적 스케줄 빌더를 사용하여 문법을 외우지 않고도 표현식을 만들 수 있습니다."
        }
      ]
    },
    "markdown-preview": {
      "whatIs": "Markdown Preview는 GFM(GitHub Flavored Markdown)을 완전히 지원하며 Markdown 텍스트를 실시간으로 렌더링합니다. README 파일, 문서, 메모에 적합합니다.",
      "howToUse": "에디터에 Markdown을 입력하거나 붙여넣으세요. 오른쪽에서 렌더링된 미리보기를 즉시 확인하세요. HTML로 내보내거나 렌더링된 콘텐츠를 복사하세요.",
      "features": [
        "실시간 라이브 미리보기",
        "GitHub Flavored Markdown 지원",
        "코드 블록 구문 강조",
        "HTML로 내보내기"
      ],
      "faq": [
        {
          "q": "GitHub Flavored Markdown이 지원되나요?",
          "a": "네. 테이블, 작업 목록, 취소선 등 모든 GFM 기능이 완전히 지원됩니다."
        },
        {
          "q": "렌더링된 HTML을 내보낼 수 있나요?",
          "a": "네. 내보내기 버튼을 사용하여 렌더링된 콘텐츠를 HTML 파일로 다운로드하세요."
        }
      ]
    },
    "diff-checker": {
      "whatIs": "Diff Checker는 두 텍스트를 비교하고 차이점을 강조 표시합니다. 코드 리뷰, 문서 비교, 변경 사항 추적에 필수적입니다.",
      "howToUse": "왼쪽에 원본 텍스트, 오른쪽에 수정된 텍스트를 붙여넣으세요. 추가, 삭제, 변경 사항이 강조 표시됩니다. 인라인과 나란히 보기 간 전환하세요.",
      "features": [
        "나란히 보기와 인라인 diff 보기",
        "줄 단위 및 문자 수준 비교",
        "코드용 구문 강조",
        "공백 무시 옵션"
      ],
      "faq": [
        {
          "q": "코드 파일을 비교할 수 있나요?",
          "a": "네. diff 체커는 코드에 적합하며 일반적인 언어에 대한 구문 강조를 포함합니다."
        },
        {
          "q": "비교에 크기 제한이 있나요?",
          "a": "큰 텍스트도 잘 작동하지만, 매우 큰 파일은 기기에 따라 느려질 수 있습니다."
        }
      ]
    },
    "url-parser": {
      "whatIs": "URL Parser는 URL을 구성 요소로 분해합니다: 프로토콜, 호스트, 경로, 쿼리 파라미터, 프래그먼트. 디버깅과 웹 주소 이해에 필수적입니다.",
      "howToUse": "URL을 붙여넣으면 구성 요소로 파싱됩니다. 쿼리 파라미터를 개별적으로 편집하세요. 어떤 부분이든 수정하여 새 URL을 빌드하세요.",
      "features": [
        "완전한 URL 구성 요소 분해",
        "쿼리 파라미터 편집기",
        "URL 인코딩/디코딩",
        "구성 요소에서 URL 빌드"
      ],
      "faq": [
        {
          "q": "어떤 URL 구성 요소가 표시되나요?",
          "a": "프로토콜, 호스트, 포트, 경로, 쿼리 파라미터, 해시 프래그먼트가 모두 표시됩니다."
        },
        {
          "q": "URL을 편집하고 재구성할 수 있나요?",
          "a": "네. 어떤 구성 요소든 수정하면 도구가 완전한 URL을 빌드해 줍니다."
        }
      ]
    },
    "regex-tester": {
      "whatIs": "Regex Tester는 정규 표현식을 검증하고 실시간으로 매칭 결과를 보여줍니다. 즉각적인 시각적 피드백으로 패턴을 테스트하고 디버그하세요.",
      "howToUse": "정규식 패턴과 테스트 문자열을 입력하세요. 매칭 결과가 즉시 강조 표시됩니다. 전역(g), 대소문자 무시(i), 멀티라인(m) 플래그를 사용하세요.",
      "features": [
        "실시간 매칭 강조",
        "캡처 그룹 표시",
        "일반적인 정규식 패턴 라이브러리",
        "플래그 토글 (g, i, m, s)"
      ],
      "faq": [
        {
          "q": "어떤 정규식 flavor가 사용되나요?",
          "a": "JavaScript 정규식 문법이 사용되며, 대부분의 현대 언어와 호환됩니다."
        },
        {
          "q": "캡처 그룹을 볼 수 있나요?",
          "a": "네. 이름 있는 캡처 그룹과 번호 있는 캡처 그룹이 매칭된 값과 함께 표시됩니다."
        }
      ]
    },
    "meta-generator": {
      "whatIs": "Meta Tag Generator는 SEO 최적화된 메타 태그, Open Graph 태그, Twitter Card를 생성합니다. 웹사이트의 검색 가시성과 소셜 공유를 개선하세요.",
      "howToUse": "페이지 제목, 설명 등 세부 정보를 입력하세요. 검색 결과와 소셜 공유에서 페이지가 어떻게 나타날지 미리 보세요. 생성된 HTML 태그를 복사하세요.",
      "features": [
        "SEO 메타 태그 생성",
        "소셜 공유용 Open Graph 태그",
        "Twitter Card 지원",
        "Google 검색 미리보기"
      ],
      "faq": [
        {
          "q": "모든 페이지에 어떤 메타 태그가 있어야 하나요?",
          "a": "최소한 title, description, viewport, charset이 필요합니다. 소셜 공유를 위해 Open Graph를 추가하세요."
        },
        {
          "q": "메타 설명은 얼마나 길어야 하나요?",
          "a": "검색 결과에서 최적의 표시를 위해 150-160자 사이로 유지하세요."
        }
      ]
    },
    "curl-builder": {
      "whatIs": "cURL Builder는 HTTP 요청 사양에서 cURL 명령을 생성합니다. API 테스트, 디버깅, 요청 예제 공유에 적합합니다.",
      "howToUse": "HTTP 메서드를 선택하고, URL을 입력하고, 필요에 따라 헤더와 본문을 추가하세요. 생성된 cURL 명령을 복사하거나 직접 실행하세요.",
      "features": [
        "모든 HTTP 메서드 지원",
        "사용자 정의 헤더 편집기",
        "요청 본문 포맷팅",
        "요청 가져오기/내보내기"
      ],
      "faq": [
        {
          "q": "기존 cURL 명령을 가져올 수 있나요?",
          "a": "네. cURL 명령을 붙여넣으면 편집을 위한 시각적 빌더로 파싱됩니다."
        },
        {
          "q": "어떤 본문 형식이 지원되나요?",
          "a": "JSON, 폼 데이터, 원시 텍스트, 멀티파트 파일 업로드가 모두 지원됩니다."
        }
      ]
    },
    "svg-optimizer": {
      "whatIs": "SVG Optimizer는 불필요한 데이터를 제거하고, 경로를 최적화하고, 마크업을 정리하여 시각적 품질을 유지하면서 SVG 파일 크기를 줄입니다.",
      "howToUse": "SVG 코드를 업로드하거나 붙여넣으세요. 크기 감소 비율과 함께 최적화된 결과를 확인하세요. 최적화된 파일을 다운로드하거나 코드를 복사하세요.",
      "features": [
        "상당한 파일 크기 감소",
        "시각적 품질 유지",
        "메타데이터와 주석 제거",
        "경로와 모양 최적화"
      ],
      "faq": [
        {
          "q": "파일 크기를 얼마나 줄일 수 있나요?",
          "a": "SVG 복잡도와 생성한 편집기에 따라 보통 30-70% 감소합니다."
        },
        {
          "q": "최적화가 SVG 외관에 영향을 주나요?",
          "a": "아니요. 최적화는 시각적 출력을 유지하면서 불필요한 데이터를 제거합니다."
        }
      ]
    },
    "css-to-tailwind": {
      "whatIs": "CSS to Tailwind는 표준 CSS 속성을 Tailwind CSS 유틸리티 클래스로 변환합니다. Tailwind로의 마이그레이션을 가속화하거나 동등한 클래스를 학습하세요.",
      "howToUse": "입력 영역에 CSS 코드를 붙여넣으세요. 동등한 Tailwind 클래스가 생성됩니다. 개별 클래스 또는 전체 변환을 복사하세요.",
      "features": [
        "즉시 CSS를 Tailwind로 변환",
        "일반적인 CSS 속성 지원",
        "Tailwind 클래스 동등 학습",
        "중첩된 선택자 처리"
      ],
      "faq": [
        {
          "q": "모든 CSS 속성을 지원하나요?",
          "a": "대부분의 일반 속성이 지원됩니다. 일부 복잡하거나 사용자 정의 속성은 직접적인 Tailwind 대응이 없을 수 있습니다."
        },
        {
          "q": "어떤 Tailwind 버전이 사용되나요?",
          "a": "기본적으로 Tailwind CSS v3.x 클래스가 생성됩니다."
        }
      ]
    },
    "prettier-playground": {
      "whatIs": "Prettier Playground는 공식 Prettier 포맷터를 사용하여 JavaScript, TypeScript, CSS, HTML, JSON 등의 코드를 포맷팅합니다.",
      "howToUse": "코드를 붙여넣고 언어를 선택하면 즉시 포맷팅됩니다. 탭 너비, 따옴표 스타일 등 Prettier 옵션을 사용자 정의하세요.",
      "features": [
        "다양한 언어 지원",
        "사용자 정의 포맷팅 옵션",
        "실시간 포맷팅",
        "공식 Prettier 엔진"
      ],
      "faq": [
        {
          "q": "어떤 언어가 지원되나요?",
          "a": "JavaScript, TypeScript, CSS, HTML, JSON, Markdown, YAML, GraphQL이 지원됩니다."
        },
        {
          "q": "포맷팅 규칙을 사용자 정의할 수 있나요?",
          "a": "네. 탭 너비, 세미콜론, 따옴표 등 Prettier 옵션을 설정하세요."
        }
      ]
    },
    "unix-timestamp": {
      "whatIs": "Unix Timestamp Converter는 Unix 에포크 타임스탬프와 사람이 읽을 수 있는 날짜 간 변환을 합니다. 로그 디버깅과 API 작업에 필수적입니다.",
      "howToUse": "Unix 타임스탬프를 입력하여 날짜를 확인하거나, 날짜를 선택하여 타임스탬프를 얻으세요. 초 및 밀리초 정밀도를 지원합니다.",
      "features": [
        "양방향 변환",
        "다양한 시간대 지원",
        "초 및 밀리초 정밀도",
        "현재 타임스탬프 표시"
      ],
      "faq": [
        {
          "q": "Unix 타임스탬프란 무엇인가요?",
          "a": "1970년 1월 1일(Unix Epoch) 이후 경과된 초 수로, 컴퓨팅에서 널리 사용됩니다."
        },
        {
          "q": "다른 시간대를 처리하나요?",
          "a": "네. 시간대를 선택하거나 일관된 변환을 위해 UTC를 사용하세요."
        }
      ]
    },
    "box-shadow": {
      "whatIs": "Box Shadow Generator는 시각적 편집기로 CSS box-shadow 효과를 만듭니다. 아름다운 그림자를 디자인하고 CSS 코드를 바로 복사하세요.",
      "howToUse": "슬라이더로 그림자 오프셋, 블러, 확산, 색상을 조정하세요. 라이브 미리보기를 보고 생성된 CSS 코드를 복사하세요.",
      "features": [
        "시각적 그림자 편집기",
        "다중 그림자 레이어",
        "내부 그림자 지원",
        "라이브 CSS 미리보기"
      ],
      "faq": [
        {
          "q": "여러 그림자를 추가할 수 있나요?",
          "a": "네. 여러 그림자를 레이어하여 복잡한 깊이 효과를 만들 수 있습니다."
        },
        {
          "q": "CSS가 크로스 브라우저 호환인가요?",
          "a": "네. 생성된 CSS는 벤더 프리픽스 없이 모든 최신 브라우저에서 작동합니다."
        }
      ]
    },
    "gradient-generator": {
      "whatIs": "Gradient Generator는 시각적 편집기로 CSS 선형 및 방사형 그라디언트를 만듭니다. 웹 프로젝트를 위한 아름다운 색상 전환을 디자인하세요.",
      "howToUse": "색상 정지점을 추가하고 위치를 조정하고 그라디언트 방향을 설정하세요. 라이브 미리보기를 보고 스타일시트에 사용할 CSS 코드를 복사하세요.",
      "features": [
        "선형 및 방사형 그라디언트",
        "다중 색상 정지점",
        "각도 및 방향 제어",
        "CSS 및 Tailwind 출력"
      ],
      "faq": [
        {
          "q": "방사형 그라디언트를 만들 수 있나요?",
          "a": "네. 선형과 방사형 그라디언트 유형 간 전환하며 완전한 사용자 정의가 가능합니다."
        },
        {
          "q": "몇 가지 색상을 사용할 수 있나요?",
          "a": "무제한입니다. 복잡한 그라디언트를 만들기 위해 원하는 만큼 색상 정지점을 추가하세요."
        }
      ]
    },
    "app-icon-generator": {
      "whatIs": "App Icon Generator는 하나의 이미지에서 iOS, Android, 웹 파비콘에 필요한 모든 아이콘 크기를 생성합니다. 수동 리사이즈 시간을 절약하세요.",
      "howToUse": "고해상도 아이콘(1024x1024 권장)을 업로드하세요. 플랫폼을 선택하고 생성된 모든 크기가 포함된 ZIP 파일을 다운로드하세요.",
      "features": [
        "iOS 및 Android 아이콘 세트",
        "파비콘 및 웹 앱 아이콘",
        "필요한 모든 크기 생성",
        "편리한 ZIP 다운로드"
      ],
      "faq": [
        {
          "q": "어떤 이미지 크기를 업로드해야 하나요?",
          "a": "모든 생성 크기에서 최상의 품질을 위해 1024x1024 픽셀을 사용하세요."
        },
        {
          "q": "어떤 플랫폼이 지원되나요?",
          "a": "iOS (모든 iPhone/iPad 크기), Android (mdpi부터 xxxhdpi까지), 웹 파비콘."
        }
      ]
    },
    "ua-parser": {
      "whatIs": "User Agent Parser는 브라우저 User Agent 문자열을 분석하여 브라우저 이름, 버전, 운영 체제, 기기 정보를 추출합니다.",
      "howToUse": "User Agent 문자열을 붙여넣거나 현재 브라우저의 UA를 사용하세요. 브라우저, OS, 기기 세부 정보를 포함한 파싱된 정보를 확인하세요.",
      "features": [
        "브라우저 감지",
        "운영 체제 식별",
        "기기 유형 인식",
        "봇 감지"
      ],
      "faq": [
        {
          "q": "어떤 정보를 추출할 수 있나요?",
          "a": "브라우저 이름/버전, OS 이름/버전, 기기 유형, 봇 여부가 표시됩니다."
        },
        {
          "q": "User Agent 파싱은 신뢰할 수 있나요?",
          "a": "일반적으로 네, 하지만 일부 브라우저는 UA를 위장합니다. 분석용으로 사용하고 보안용으로는 사용하지 마세요."
        }
      ]
    },
    "lorem-generator": {
      "whatIs": "Lorem Ipsum Generator는 디자인 목업과 개발을 위한 플레이스홀더 텍스트를 생성합니다. 필요에 따라 단어, 문장 또는 문단을 생성하세요.",
      "howToUse": "유형(단어, 문장, 문단)과 수량을 선택하세요. 생성을 클릭하여 플레이스홀더 텍스트를 만들고 클립보드에 복사하세요.",
      "features": [
        "단어, 문장, 문단",
        "사용자 정의 수량",
        "클래식 Lorem Ipsum 텍스트",
        "원클릭 복사"
      ],
      "faq": [
        {
          "q": "Lorem Ipsum이란 무엇인가요?",
          "a": "1500년대부터 디자인에 사용된 플레이스홀더 텍스트로, 라틴 문학에 기반합니다."
        },
        {
          "q": "실제 텍스트 대신 Lorem Ipsum을 사용하는 이유는?",
          "a": "읽을 수 있는 콘텐츠의 방해 없이 시각적 디자인에 집중하는 데 도움이 됩니다."
        }
      ]
    },
    "url-encoder": {
      "whatIs": "URL Encoder/Decoder는 특수 문자를 URL 안전 형식(퍼센트 인코딩)으로 변환하거나 그 반대로 변환합니다. 웹 URL 및 쿼리 문자열 작업에 필수적입니다.",
      "howToUse": "URL용으로 인코딩할 텍스트를 붙여넣거나 인코딩된 텍스트를 붙여넣어 디코딩하세요. 전체 인코딩과 컴포넌트 전용 인코딩 간 전환하세요.",
      "features": [
        "특수 문자 인코딩",
        "퍼센트 인코딩된 문자열 디코딩",
        "컴포넌트 및 전체 URL 모드",
        "유니코드 문자 처리"
      ],
      "faq": [
        {
          "q": "어떤 문자가 URL 인코딩이 필요한가요?",
          "a": "공백, 특수 문자(&, =, ?, #), 비ASCII 문자가 인코딩이 필요합니다."
        },
        {
          "q": "인코딩 모드의 차이점은 무엇인가요?",
          "a": "컴포넌트 인코딩은 쿼리 값용이고; 전체 인코딩은 전체 URL 문자열을 처리합니다."
        }
      ]
    },
    "html-entity": {
      "whatIs": "HTML Entity Encoder는 특수 문자를 HTML 엔티티로 변환하거나 그 반대로 변환합니다. XSS 공격을 방지하고 웹 페이지에서 특수 문자를 올바르게 표시하세요.",
      "howToUse": "특수 문자가 있는 텍스트를 입력하여 인코딩하거나, HTML 엔티티를 붙여넣어 디코딩하세요. 변환된 결과를 보고 HTML에 사용하기 위해 복사하세요.",
      "features": [
        "이름 및 숫자 엔티티",
        "보안 중심 인코딩",
        "모든 특수 문자 처리",
        "대량 변환"
      ],
      "faq": [
        {
          "q": "HTML 엔티티를 사용하는 이유는?",
          "a": "<, >, & 같은 문자를 HTML에서 올바르게 표시하고 보안 문제를 방지하기 위함입니다."
        },
        {
          "q": "이름 엔티티와 숫자 엔티티의 차이점은?",
          "a": "이름(&amp;)은 읽기 쉽고; 숫자(&#38;)는 모든 유니코드 문자에 작동합니다."
        }
      ]
    }
  },
  "cheatsheets": {
    "title": "개발자 치트시트",
    "description": "개발자를 위한 빠른 참조 가이드",
    "git": {
      "title": "Git 명령어 치트시트",
      "description": "Git 명령어 전체 참조 - init, clone, commit, push, pull, branch, merge 등"
    },
    "http-status": {
      "title": "HTTP 상태 코드",
      "description": "HTTP 상태 코드 전체 목록 - 1xx, 2xx, 3xx, 4xx, 5xx 상세 설명"
    },
    "regex": {
      "title": "정규표현식 문법 치트시트",
      "description": "정규표현식 패턴 및 문법 참조 - 메타문자, 수량자, 그룹, 예제"
    },
    "mime-types": {
      "title": "MIME 타입 참조",
      "description": "웹 개발에서 사용하는 MIME 타입 - text, image, audio, video, application"
    },
    "javascript": {
      "title": "JavaScript 치트시트",
      "description": "JavaScript 전체 참조 - 변수, 배열, 객체, 함수, async/await, 클래스, ES6+ 기능"
    },
    "css": {
      "title": "CSS 치트시트",
      "description": "CSS 빠른 참조 - 선택자, Flexbox, Grid, 포지셔닝, 타이포그래피, 애니메이션, 미디어 쿼리"
    },
    "typescript": {
      "title": "TypeScript 치트시트",
      "description": "TypeScript 참조 - 타입, 인터페이스, 제네릭, 유틸리티 타입, 타입 가드, 고급 패턴"
    },
    "react": {
      "title": "React 치트시트",
      "description": "React 참조 - 컴포넌트, 훅(useState, useEffect, useRef), Context, 패턴, React 18/19 기능"
    },
    "vue": {
      "title": "Vue.js 치트시트",
      "description": "Vue 3 참조 - Composition API, 반응성, 디렉티브, 라이프사이클 훅, Pinia, Vue Router"
    },
    "nextjs": {
      "title": "Next.js 치트시트",
      "description": "Next.js App Router 참조 - 서버 컴포넌트, 라우팅, 메타데이터, 캐싱, API 라우트"
    },
    "tailwind": {
      "title": "Tailwind CSS 치트시트",
      "description": "Tailwind CSS 참조 - 유틸리티 클래스, Flexbox, Grid, 반응형 디자인, 커스텀 값"
    },
    "nodejs": {
      "title": "Node.js 치트시트",
      "description": "Node.js 참조 - fs, path, http, process, events, child_process, 내장 모듈"
    },
    "docker": {
      "title": "Docker 치트시트",
      "description": "Docker 참조 - 컨테이너, 이미지, Dockerfile, docker-compose, 네트워크, 볼륨"
    },
    "bash": {
      "title": "Bash/Shell 치트시트",
      "description": "Bash 참조 - 명령어, 파일 작업, 파이프, 스크립팅, 시스템 관리"
    }
  },
  "guides": {
    "title": "개발자 가이드",
    "description": "개발 도구를 완벽하게 활용하기 위한 단계별 가이드",
    "viewGuide": "가이드 보기",
    "backToGuides": "가이드 목록으로",
    "tableOfContents": "목차",
    "relatedTools": "관련 도구",
    "difficulty": "난이도",
    "readTime": "읽기 시간",
    "minutes": "분",
    "tryItYourself": "직접 사용해보기",
    "previousGuide": "이전 가이드",
    "nextGuide": "다음 가이드",
    "difficultyLevels": {
      "beginner": "초급",
      "intermediate": "중급",
      "advanced": "고급"
    },
    "json-formatter": {
      "summary": "JSON 데이터를 효과적으로 포맷하고, 검증하고, 디버깅하는 방법을 배워보세요",
      "sections": {
        "what-is-json": {
          "title": "JSON이란 무엇인가요?",
          "content": "JSON(JavaScript Object Notation)은 가벼운 데이터 교환 형식입니다. 사람이 읽고 쓰기 쉽고, 기계가 파싱하고 생성하기도 쉽습니다.\n\nJSON은 두 가지 구조로 이루어집니다:\n• 이름/값 쌍의 모음 (객체나 딕셔너리처럼)\n• 값의 순서 있는 목록 (배열처럼)\n\nJSON은 언어 독립적이지만 C 계열 언어 프로그래머에게 익숙한 규칙을 사용합니다."
        },
        "common-errors": {
          "title": "흔한 JSON 오류와 해결 방법",
          "content": "개발자들이 자주 겪는 JSON 문법 오류입니다:\n\n1. 키에 따옴표 누락 - JSON에서 모든 키는 큰따옴표로 감싼 문자열이어야 합니다\n2. 후행 쉼표 - JavaScript와 달리 JSON은 후행 쉼표를 허용하지 않습니다\n3. 작은따옴표 - JSON은 문자열에 큰따옴표만 허용합니다\n4. 이스케이프되지 않은 문자 - 줄바꿈이나 탭 같은 특수 문자는 이스케이프해야 합니다\n5. 주석 - JSON은 주석을 지원하지 않습니다 (JSONC를 사용하세요)"
        },
        "how-to-use": {
          "title": "JSON Formatter 사용 방법",
          "content": "JSON Formatter 사용은 간단합니다:\n\n1. 왼쪽 입력 영역에 JSON을 붙여넣으세요\n2. 포맷된 결과가 오른쪽에 자동으로 나타납니다\n3. 원하는 들여쓰기를 선택하세요 (2칸, 4칸, 또는 탭)\n4. 압축 버튼으로 프로덕션용 JSON을 만드세요\n5. 복사 버튼을 클릭해서 클립보드에 저장하세요\n\n도구가 실시간으로 JSON을 검증하고 구문 오류의 정확한 위치를 표시합니다."
        },
        "advanced-features": {
          "title": "고급 기능",
          "content": "기본 포맷팅 외에도 제공하는 기능:\n\n• 압축 - 모든 공백을 제거하여 파일 크기 줄이기\n• 검증 - 오류 메시지와 함께 실시간 구문 검사\n• 줄 번호 - 큰 JSON 파일에서 쉬운 탐색\n• 다크 모드 - 어두운 환경에서 편안한 보기\n• 데이터 전송 없음 - 모든 처리가 브라우저에서 이루어집니다"
        },
        "api-debugging": {
          "title": "실전 예제: API 디버깅",
          "content": "API 응답을 디버깅할 때 포맷된 JSON은 필수입니다:\n\n1. 브라우저 네트워크 탭에서 원시 API 응답을 복사하세요\n2. 포매터에 붙여넣어 구조를 명확하게 확인하세요\n3. 중첩된 객체, 배열, 데이터 타입을 파악하세요\n4. 애플리케이션에 필요한 특정 필드를 찾으세요\n\n이 워크플로우는 복잡한 API 작업 시간을 크게 줄여주고 데이터 구조를 빠르게 이해할 수 있게 해줍니다."
        }
      }
    },
    "jwt-decoder": {
      "summary": "JWT 토큰을 이해하고, 안전하게 디코딩하고, 인증 문제를 디버깅하세요",
      "sections": {
        "what-is-jwt": {
          "title": "JWT란 무엇인가요?",
          "content": "JWT(JSON Web Token)는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준입니다.\n\nJWT의 일반적인 용도:\n• 인증 - 사용자 신원 증명\n• 권한 부여 - 리소스 접근 허용\n• 정보 교환 - 안전한 데이터 전송\n\nJWT는 점(.)으로 구분된 세 부분으로 구성됩니다: header.payload.signature"
        },
        "jwt-structure": {
          "title": "JWT 구조 설명",
          "content": "모든 JWT는 세 부분으로 구성됩니다:\n\n1. 헤더 - 토큰 타입(JWT)과 서명 알고리즘(HS256이나 RS256 등) 포함\n\n2. 페이로드 - 클레임(사용자와 추가 데이터에 대한 정보) 포함\n\n3. 서명 - 토큰이 변조되지 않았음을 검증\n\n헤더와 페이로드 모두 Base64Url로 인코딩된 JSON 객체입니다."
        },
        "common-claims": {
          "title": "일반적인 JWT 클레임",
          "content": "자주 보게 되는 표준 클레임:\n\n• iss (발급자) - 토큰을 생성한 주체\n• sub (주제) - 토큰이 식별하는 대상 (보통 사용자 ID)\n• aud (대상자) - 토큰의 의도된 수신자\n• exp (만료 시간) - 토큰 만료 시점 (Unix 타임스탬프)\n• iat (발급 시간) - 토큰 생성 시점\n• nbf (유효 시작 시간) - 이 시간 전에는 토큰 무효\n• jti (JWT ID) - 토큰의 고유 식별자\n\n커스텀 클레임은 애플리케이션별 데이터를 담을 수 있습니다."
        },
        "debugging-expired": {
          "title": "만료된 토큰 디버깅",
          "content": "토큰 만료는 흔한 문제입니다. 디버깅 방법:\n\n1. 토큰을 디코딩해서 페이로드 확인\n2. 'exp' 클레임(만료 타임스탬프) 찾기\n3. 타임스탬프를 읽기 쉬운 날짜로 변환\n4. 현재 시간과 비교\n\n저희 디코더는 만료 상태를 자동으로 표시합니다 - 빨간색 '만료됨' 또는 녹색 '유효함' 배지를 확인하세요.\n\n일반적인 해결책:\n• 만료 전에 토큰 갱신\n• 서버/클라이언트 시간 동기화 확인\n• 인증 서버의 토큰 수명 설정 확인"
        },
        "security-tips": {
          "title": "JWT 보안 모범 사례",
          "content": "JWT를 안전하게 유지하세요:\n\n1. 페이로드에 민감한 데이터 저장 금지 - 인코딩된 것이지 암호화된 것이 아닙니다\n2. 짧은 만료 시간 사용 - 장기 액세스 토큰 대신 리프레시 토큰 사용\n3. 서버 측에서 토큰 검증 - 클라이언트 측 검증만 신뢰하지 마세요\n4. HTTPS 사용 - 토큰 가로채기 방지\n5. 토큰 안전하게 저장 - HttpOnly 쿠키가 localStorage보다 안전\n6. 토큰 폐기 구현 - 로그아웃 및 보안 이벤트용\n\n기억하세요: JWT는 디코딩되는 것이지 복호화되는 것이 아닙니다. 누구나 페이로드를 읽을 수 있습니다!"
        }
      }
    },
    "base64-converter": {
      "summary": "이미지, 파일, 데이터 전송을 위한 Base64 인코딩 마스터하기",
      "sections": {
        "what-is-base64": {
          "title": "Base64란 무엇인가요?",
          "content": "Base64는 바이너리 데이터를 ASCII 문자로 변환하는 바이너리-텍스트 인코딩 방식입니다.\n\nBase64가 존재하는 이유:\n• 텍스트 전용 채널(이메일 등)을 통해 바이너리 데이터를 안전하게 전송\n• 텍스트 형식(JSON, XML 등)에 바이너리 데이터 삽입\n• 별도 파일 없이 HTML/CSS에 이미지 직접 포함\n\nBase64는 64개의 문자를 사용합니다: A-Z, a-z, 0-9, +, / (패딩용 =)"
        },
        "encoding-images": {
          "title": "웹용 이미지 인코딩",
          "content": "Base64로 인코딩된 이미지는 HTML이나 CSS에 직접 삽입할 수 있습니다:\n\n장점:\n• HTTP 요청 감소\n• 한번 로드되면 오프라인 작동\n• 간단한 배포 (별도 이미지 파일 불필요)\n\n단점:\n• 바이너리보다 ~33% 더 큼\n• 브라우저 캐싱 안됨\n• HTML/CSS 파일 크기 증가\n\n모범 사례: 10KB 미만의 작은 이미지(아이콘, 로고)에 Base64 사용."
        },
        "common-use-cases": {
          "title": "일반적인 사용 사례",
          "content": "Base64가 필수인 경우:\n\n1. 데이터 URL - 웹 페이지에 리소스 삽입\n2. 이메일 첨부 - MIME 인코딩\n3. API 페이로드 - JSON에서 바이너리 데이터 전송\n4. 인증 - Basic auth 헤더 (username:password)\n5. 인증서 - SSL/TLS용 PEM 형식\n\n저희 도구는 텍스트와 파일을 처리하고 적절한 데이터 URL을 자동으로 생성합니다."
        },
        "data-urls": {
          "title": "데이터 URL 이해하기",
          "content": "데이터 URL은 콘텐츠를 URL에 직접 삽입합니다:\n\n형식: data:[mediatype][;base64],<data>\n\n구성 요소:\n• data: - URL 스키마\n• mediatype - MIME 타입 (예: image/png, text/plain)\n• ;base64 - Base64 인코딩 표시\n• data - 실제 인코딩된 콘텐츠\n\n데이터 URL은 일반 URL이 작동하는 모든 곳에서 작동합니다: img src, CSS url(), fetch() 등."
        },
        "size-considerations": {
          "title": "크기와 성능",
          "content": "중요한 고려 사항:\n\n• Base64는 크기를 ~33% 증가시킵니다 (3바이트가 4문자가 됨)\n• 큰 Base64 문자열은 페이지 렌더링을 느리게 할 수 있습니다\n• 브라우저 디코드 제한은 다양합니다 (보통 몇 MB까지 안전)\n• 텍스트 기반 형식에는 gzip 압축 고려\n\n경험법칙:\n• 10KB 미만: Base64가 보통 유리\n• 10-50KB: 상황에 따라 평가\n• 50KB 초과: 일반 파일 URL 사용"
        }
      }
    },
    "regex-tester": {
      "summary": "검증과 파싱을 위한 실용적인 예제로 정규표현식 배우기",
      "sections": {
        "what-is-regex": {
          "title": "Regex란 무엇인가요?",
          "content": "정규표현식(regex)은 문자열에서 문자 조합을 매칭하는 데 사용되는 패턴입니다.\n\nRegex의 용도:\n• 검증 - 입력이 패턴과 일치하는지 확인\n• 검색 - 패턴과 일치하는 텍스트 찾기\n• 추출 - 문자열에서 특정 데이터 가져오기\n• 치환 - 패턴 기반으로 텍스트 변환\n\nregex 문법은 처음에는 암호처럼 보이지만, 익히면 매우 강력합니다."
        },
        "email-validation": {
          "title": "이메일 검증 패턴",
          "content": "이메일 검증은 가장 흔한 regex 사용 사례 중 하나입니다.\n\n기본 이메일 패턴이 확인하는 것:\n• 사용자명 부분 (문자, 숫자, 점, 하이픈)\n• @ 기호\n• 도메인 이름\n• TLD (최상위 도메인)\n\n참고: regex만으로 완벽한 이메일 검증은 사실 불가능합니다. 가장 좋은 방법은 간단한 패턴과 확인 이메일 발송입니다."
        },
        "phone-validation": {
          "title": "전화번호 패턴",
          "content": "전화번호는 국가와 형식에 따라 다양합니다:\n\n미국 형식 고려 사항:\n• 123-456-7890 (대시)\n• (123) 456-7890 (괄호)\n• +1 123 456 7890 (국제)\n\n국제 지원을 위해서는 E.164 형식(+[국가코드][번호])이 가장 신뢰할 수 있습니다.\n\n팁: 전화번호를 정규화된 형식으로 저장하고 사용자 로케일에 맞게 표시하세요."
        },
        "common-patterns": {
          "title": "일반적인 Regex 패턴",
          "content": "모든 개발자가 알아야 할 패턴:\n\n• URL - http/https URL 매칭\n• IP 주소 - IPv4 주소 검증\n• 날짜 - YYYY-MM-DD 형식 매칭\n• Hex 색상 - #RGB 또는 #RRGGBB 매칭\n• 비밀번호 - 복잡성 요구사항 적용\n\n저희 도구에는 빠른 참조를 위한 이러한 패턴 라이브러리가 포함되어 있습니다."
        },
        "flags-modifiers": {
          "title": "Regex 플래그와 수정자",
          "content": "플래그는 regex 엔진의 매칭 방식을 변경합니다:\n\n• g (global) - 첫 번째가 아닌 모든 매치 찾기\n• i (case-insensitive) - 대소문자 무시\n• m (multiline) - ^와 $가 줄 시작/끝과 매칭\n• s (dotall) - .이 줄바꿈도 매칭\n• u (unicode) - 전체 유니코드 지원\n• y (sticky) - 정확한 위치에서만 매칭\n\n필요에 따라 플래그 조합: /pattern/gi로 전역 대소문자 무시 매칭."
        }
      }
    },
    "hash-generator": {
      "summary": "암호화 해시를 이해하고 MD5, SHA-256, SHA-512 사용 시기 알아보기",
      "sections": {
        "what-is-hash": {
          "title": "해시란 무엇인가요?",
          "content": "해시 함수는 어떤 크기의 입력이든 받아서 고정 크기의 출력(해시 또는 다이제스트)을 생성합니다.\n\n핵심 특성:\n• 결정적 - 같은 입력은 항상 같은 출력\n• 단방향 - 해시에서 원본 입력을 역산할 수 없음\n• 충돌 저항성 - 다른 입력이 같은 해시를 생성하기 어려움\n• 눈사태 효과 - 작은 입력 변화가 매우 다른 해시 생성\n\n해시는 데이터의 지문입니다 - 모든 콘텐츠의 고유 식별자."
        },
        "md5-vs-sha": {
          "title": "MD5 vs SHA: 무엇을 사용할까요?",
          "content": "올바른 알고리즘 선택:\n\nMD5 (128비트):\n• 빠르지만 암호학적으로 취약\n• 체크섬에는 OK, 보안에는 NO\n• 의도적으로 충돌 생성 가능\n\nSHA-1 (160비트):\n• 보안 용도로 사용 중단\n• 레거시 시스템에서 여전히 사용\n\nSHA-256 (256비트):\n• 대부분의 용도에 현재 표준\n• 보안과 속도의 좋은 균형\n\nSHA-512 (512비트):\n• 최대 보안\n• 약간 느림, 더 긴 출력"
        },
        "use-cases": {
          "title": "실제 사용 사례",
          "content": "해시는 소프트웨어 어디에나 있습니다:\n\n1. 파일 무결성 - 다운로드가 손상되지 않았는지 확인\n2. 비밀번호 저장 - 평문이 아닌 해시 저장 (bcrypt/argon2 사용!)\n3. 데이터 중복 제거 - 해시로 중복 파일 식별\n4. Git 커밋 - SHA-1이 모든 커밋을 식별\n5. 블록체인 - 해시 체인이 무결성 보장\n\n중요: 비밀번호에는 SHA-256이 아닌 특화된 해싱(bcrypt, argon2)을 사용하세요!"
        },
        "hash-verification": {
          "title": "파일 무결성 검증",
          "content": "중요한 다운로드는 항상 검증하세요:\n\n1. 파일 다운로드\n2. 공식 소스에서 예상 해시 확인\n3. 다운로드한 파일의 해시 계산\n4. 두 해시 비교\n\n정확히 일치하면 파일이 수정되지 않은 것입니다. 1비트만 달라도 완전히 다른 해시가 생성됩니다.\n\n저희 도구로 쉽게 할 수 있습니다 - 예상 해시를 붙여넣으면 일치 여부를 알려드립니다."
        },
        "security-best-practices": {
          "title": "보안 모범 사례",
          "content": "해시 보안 가이드라인:\n\n• 보안 목적으로 MD5나 SHA-1 사용 금지\n• 데이터 무결성에는 SHA-256이나 SHA-512 사용\n• 비밀번호에는 bcrypt, scrypt, argon2 사용 (솔트와 함께)\n• 평문이 아닌 해시 저장\n• 타이밍 공격 방지를 위해 상수 시간 비교 사용\n• 인증이 필요하면 HMAC 고려\n\n기억하세요: 해시는 무결성을 검증하지만 기밀성은 검증하지 않습니다. 데이터를 비밀로 유지해야 하면 암호화를 사용하세요."
        }
      }
    }
  }
}
